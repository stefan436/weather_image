<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wetter von Stefan</title>
  
  <!-- App Icon f√ºr iOS Homescreen -->
  <link rel="apple-touch-icon" href="icons/app_icon.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Wetter von Stefan">


  <!-- Beide Styles einbinden -->
  <link rel="stylesheet" href="styles/Hamburgermenu_design.css">
  <link rel="stylesheet" href="styles/style_mosmix_L_vorhersage.css">

  <!-- JS f√ºr Mosmix -->
  <script src="scripts/elementNamesMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <!-- JS f√ºr uv und pt -->
   <script src="scripts/uv_and_pt_script.js"></script>

</head>
<body>
  <!-- Navigation -->
  <header>
    <nav class="navbar">
      <a href="#" class="logo">Wetterinfo</a>
      <div class="hamburger-menu" id="hamburger-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <ul class="nav-links" id="nav-menu">
        <li><a href="Regenradar.html">RADVOR Bild</a></li>
        <li><a href="Regenradar_vorhersage.html">RV Radarkomposit (Nowcasting)</a></li>
        <li><a href="Aktuelle_Temperatur.html">Aktuelle Messwerte</a></li>
        <li><a href="https://www.sat24.com/en-gb/country/de">Satellitenbild <span style="font-size: 0.8em;">üîó</span></a></li>

      </ul>
    </nav>
  </header>

  <!-- Hauptinhalt -->
  <main style="padding: 12px;">
    <h1>Aktuelle Mosmix Vorhersage</h1>

    <div class="row">
      <button id="loadButton" class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
      <label for="plotSelect"><strong>Plot-Parameter:</strong></label>
      <select id="plotSelect" disabled></select>
      <span id="status" class="badge">Bereit</span>
    </div>

    <div id="station" class="meta"></div>

    <section id="weather-summary" class="weather-summary">

      <div class="day-selector-wrapper">
        <button class="day-arrow left" id="day-left">&#10094;</button>
        <div id="day-selector" class="day-selector"></div>
        <button class="day-arrow right" id="day-right">&#10095;</button>
      </div>

      <div id="scroll-container" class="scroll-container"></div>
    </section>




    <div id="plot">
      <div id="plotlyDiv"></div>
    </div>

    <div class="row" style="margin-top: 20px;">
      <span id="infoText" class="infoBadge">
        <strong>Hinweise:</strong> 
        <ul>
          <li>Die Daten stammen vom Deutschen Wetterdienst (Model Output Statistics-MIX (MOSMIX)).</li>
          <li>Die "Gef√ºhlte Temperatur" und der "UV-Index" werden aus einer seperaten Datei (DWD) abgerufen und werden f√ºr den n√§chstgelegenen Vorhersagepunkt zum Standort angegeben.</li>
          <li>Die Zusammenfassung zeigt die dominierenden Wetterbedingungen (signifikanteste Wettersituation) f√ºr Nachts (2-6 Uhr), Fr√ºhs (6-10 Uhr), Mittags (10-14 Uhr), Nachmittags (14-18 Uhr), Abends (18-22 Uhr) und Sp√§t Abends (22-02 Uhr).</li>
        </ul>
      </span>
    </div>

    <div class="row" style="margin-top: 20px;">
      <button id="reloadButton" class="btn" onclick="location.reload()">Seite neu laden</button>
    </div>

  </main>

  <!-- Hamburger-Skript -->
  <script src="scripts/Hamburgermenu_script.js"></script>

  <!-- Mosmix Script -->
  <script>

    const wwIconMap = {
      // Gewitter
      95: { icon: "thunderstorm.png", label: "Gewitter mit Regen/Schnee" },

      // gefrierender Spr√ºhregen/Regen
      57: { icon: "freezing-rain.png", label: "Starker gefrierender Spr√ºhregen" },
      56: { icon: "freezing-rain.png", label: "Leichter gefrierender Spr√ºhregen" },
      67: { icon: "freezing-rain.png", label: "Starker gefrierender Regen" },
      66: { icon: "freezing-rain.png", label: "Leichter gefrierender Regen" },

      // Schnee/Schneeschauer
      86: { icon: "snow.png", label: "Starker Schneeschauer" },
      85: { icon: "snow.png", label: "Leichter Schneeschauer" },
      84: { icon: "sleet.png", label: "Starker Schneeregenschauer" },
      83: { icon: "sleet.png", label: "Leichter Schneeregenschauer" },
      75: { icon: "snow.png", label: "Starker Schneefall" },
      73: { icon: "snow.png", label: "M√§√üiger Schneefall" },
      71: { icon: "snow.png", label: "Leichter Schneefall" },
      69: { icon: "sleet.png", label: "Starker Schneeregen" },
      68: { icon: "sleet.png", label: "Leichter Schneeregen" },

      // Regen/Schauer
      82: { icon: "rain.png", label: "Heftiger Regenschauer" },
      81: { icon: "rain.png", label: "Starker Regenschauer" },
      80: { icon: "rain.png", label: "Leichter Regenschauer" },
      65: { icon: "rain.png", label: "Starker Regen" },
      63: { icon: "rain.png", label: "M√§√üiger Regen" },
      61: { icon: "rain.png", label: "Leichter Regen" },

      // Spr√ºhregen
      55: { icon: "rain.png", label: "Starker Spr√ºhregen" },
      53: { icon: "rain.png", label: "M√§√üiger Spr√ºhregen" },
      51: { icon: "rain.png", label: "Leichter Spr√ºhregen" },

      // Nebel
      49: { icon: "fog.png", label: "Nebel mit Reif" },
      45: { icon: "fog.png", label: "Nebel" },

      // Bew√∂lkung
      3:  { icon: "total cloud.png", label: "Bew√∂lkung zunehmend" },
      2:  { icon: "medium cloud.png", label: "Bew√∂lkung unver√§ndert" },
      1:  { icon: "low cloud.png", label: "Bew√∂lkung abnehmend" },
      0:  { icon: "day-and-night.png", label: "Klarer Himmel" }
    };

    // gew√ºnschte Reihenfolge
    const preferredOrder = [
      "Temperatur",
      "Niederschlagswahrscheinlichkeit",
      "Totale Niderschlagsmenge",
      "Niederschlagsdauer",
      "Gewitterwahrscheinlichkeit",
      "Bew√∂lkung",  
      "Windgeschwindigkeit", 
      "Maximale Windb√∂e",
      "Windrichtung",
      "Sichtweite",
      "Nebelwahrscheinlichkeit", 
      "Wahrscheinlichkeit Sichtweite < 1km", 
      "Sonnenscheindauer", 
      "UV-Index",
      "Strahlungsintensit√§t", 
      "reduzierter Oberfl√§chendruck"
    ];
  

    // K√ºrzel, die nicht im Dropdown auftauchen sollen
    const excludedElements = [
      "E_PPP", "E_Td", "FX3", "FX625", "FX640", "FX655", "FXh", "FXh25", "FXh40",
      "PSd00", "PSd30", "PSd60", "R101", "R102", "R103", "R105", "R107", "R110",
      "R120", "R130", "R150", "R600", "R602", "R610", "R650", "RRad1", "Rd00",
      "Rd02", "Rd10", "Rd50", "Rh00", "Rh02", "Rh10", "Rh50", "RR1o1", "RR1u1",
      "RR1w1", "RR3c", "RR6c", "RRdc", "RRhc", "RRL1c", "RRS1c", "RRS3c", "RSunD",
      "SunD", "SunD3", "T5cm", "Td", "TG", "TM", "W1W2", "WPc11", "WPc31", "WPc61",
      "WPcd1", "WPch1", "ww", "ww3", "wwC", "wwC6", "wwCh", "wwD", "wwD6", "wwDh",
      "wwF", "wwF6", "wwFh", "wwL", "wwL6", "wwLh", "wwM6", "wwMd", "wwMh", "wwP6",
      "wwPd", "wwPh", "wwS", "wwS6", "wwSh", "wwT6", "wwTd", "wwTh", "wwZ",
      "wwZ6", "wwZh", "FXh55", "N05", "Nh", "Nl", "Nlm", "Nm", "PEvap", "TX", "TN", "N", "Gef√ºhlte Temperatur"
    ];
 
    // Kombinationen von Werten + ihren Fehlern
    const combinedParams = [
      { value: "Temperatur", error: "Absolute error temperature 2m above surface" },
      { value: "Windgeschwindigkeit", error: "Absolute error wind speed 10m above surface" },
      { value: "Windrichtung", error: "Absolute error wind direction" }
    ];

    let closest_station_id = null;
    let minDistance = Infinity;
    let userLat = null;
    let userLon = null;
    let result_uv_and_pt = null;
    const statusEl = document.getElementById("status");
    const stationEl= document.getElementById("station");
    const plotSel  = document.getElementById("plotSelect");
    const plotlyDiv= document.getElementById("plotlyDiv");

    let lastWide = null;
    let seriesMap = {};
    let timeSteps = [];

    function setStatus(txt) {
      statusEl.textContent = txt;
      statusEl.style.display = txt ? "inline-block" : "none";
    }


    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const œÜ1 = toRadians(lat1),
            œÜ2 = toRadians(lat2);
      const ŒîœÜ = toRadians(lat2 - lat1),
            ŒîŒª = toRadians(lon2 - lon1);
      const a = Math.sin(ŒîœÜ / 2) ** 2 +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function renderStationChoices(stations) {
      // √úberschrift + Container f√ºr die Buttons
      stationEl.innerHTML = `
        <div class="station-info">
          <b>N√§chste Stationen gefunden:</b>
          <div class="station-choices"></div>
        </div>
      `;

      const container = stationEl.querySelector(".station-choices");

      stations.forEach(st => {
        const btn = document.createElement("button");
        btn.textContent = `${st.description} (${Math.round(st.distance)} m)`;
        btn.className = "btn station-btn";
        btn.onclick = () => {
          closest_station_id = st.station_id;
          minDistance = st.distance;
          setStatus(`Station ${st.station_id} gew√§hlt ‚Äì lade KMZ ‚Ä¶`);
          loadMosmixData(st.station_id);
        };
        container.appendChild(btn);
      });
    }


    async function findNearestStation() {
      setStatus("Lade Stationsliste ‚Ä¶");
      try {
        const response = await fetch('data/mosmix_stationen_coords.json');
        if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
        const data = await response.json();

        if (!navigator.geolocation) {
          setStatus('Geolocation wird nicht unterst√ºtzt.');
          return;
        }

        navigator.geolocation.getCurrentPosition(async position => {
          userLat = position.coords.latitude;
          userLon = position.coords.longitude;

          // Alle Stationen mit Distanz berechnen
          const stationsWithDist = data.map(row => {
            const lat = parseFloat(row.lat);
            const lon = parseFloat(row.lon);
            if (isNaN(lat) || isNaN(lon)) return null;
            const distance = haversineDistance(userLat, userLon, lat, lon);
            return { ...row, distance };
          }).filter(Boolean);

          // nach Distanz sortieren
          stationsWithDist.sort((a, b) => a.distance - b.distance);

          // Top 5
          const nearestFive = stationsWithDist.slice(0, 5);

          // Buttons rendern
          renderStationChoices(nearestFive);
        }, error => {
          setStatus('Fehler beim Standortzugriff: ' + error.message);
        });


      } catch (err) {
        setStatus('Fehler: ' + err.message);
      }
    }

    async function loadMosmixData(stationId) {
      try {
        const proxy = 'https://cors-proxy-for-weather-app.stefan-wiedemann01.workers.dev?url=';
        const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
        const url = proxy + encodeURIComponent(baseUrl);

        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
        const blob = await resp.blob();

        const zip = await JSZip.loadAsync(blob);
        const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
        if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
        const kmlText = await zip.files[kmlFile].async("string");

        parseKML(kmlText);
      } catch (err) {
        setStatus("Fehler: " + err.message);
      }
    }

    const unitConversionMap = {
      K: v => v - 273.15,
      "m/s": v => v * 3.6,
      Pa: v => v / 100,
      "kg/m2": v => v,
      "s": v => v / 60,
      "1std kJ/m2": v => v / 3.6,
      "3std kJ/m2": v => v / 10.8,
      "m": v => v,
      "Sichtweite m": v => v / 1000,
      "%": v => v,
      "-": v => v,
      "0¬∞..360¬∞": v => v
    };

    const elementUnitsMap = {
      TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
      FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
      DD: "0¬∞..360¬∞", E_DD: "0¬∞..360¬∞",
      PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
      RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
      Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
      VV: "Sichtweite m", H_BsC: "m",
      SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
    };


    // periods; Die Vorhersage f√ºr das signifikante Wetter vorhergesagt um 7 uhr bedeutet das Wetter zwischen 6:00 und 6.59 Uhr (within last hour)
    const periods = [
      { name: "Fr√ºh", startHour: 6,  endHour: 10 },
      { name: "Mittag",    startHour: 10, endHour: 14 },
      { name: "Nachmittag" ,startHour: 14, endHour: 18 },
      { name: "Abend",     startHour: 18, endHour: 22 },
      { name: "Sp√§t Abends", startHour:22, endHour:2 },
      { name: "Nacht",     startHour: 2, endHour: 6 }
    ];

    const periodOrder = ["Nacht", "Fr√ºh", "Mittag", "Nachmittag", "Abend", "Sp√§t Abends"];

    /**
    * buildSummary: erstellt die Tag-Auswahl und rendert beim Klick die Summary-Karten
    * Ben√∂tigt global: timeSteps (Array), seriesMap["Significant Weather"] (Array gleicher L√§nge), wwIconMap (Objekt)
    */
    function buildSummary() {
      if (!seriesMap || !seriesMap["Significant Weather"]) {
        console.warn("Kein Wettercode (ww) verf√ºgbar ‚Äì keine Zusammenfassung m√∂glich");
        return;
      }

      const container = document.getElementById("scroll-container");
      const selector = document.getElementById("day-selector");
      container.innerHTML = "";
      selector.innerHTML = "";

      const now = new Date();
      now.setMinutes(0, 0, 0); // Minuten, Sekunden, Millisekunden auf 0 setzen

      // ********* Schritt 1: Roh-Eintr√§ge vorbereiten *********
      const entries = timeSteps.map((ts, i) => {
        const dateObj = new Date(ts);
        const code = parseInt(seriesMap["Significant Weather"][i]);
        return { timestamp: dateObj, hour: dateObj.getHours(), code, index: i };
      });

      // ********* Schritt 2: nur zuk√ºnftige Eintr√§ge (ab jetzt) *********
      const futureEntries = entries.filter(e => e.timestamp >= now);

      // ********* Schritt 3: nach Tag (ISO YYYY-MM-DD) und Periode gruppieren *********
      const daysMap = {};

      for (const entry of futureEntries) {
        const period = periods.find(p => {
          if (p.startHour < p.endHour) {
            return entry.hour >= p.startHour && entry.hour < p.endHour;
          } else {
            return entry.hour >= p.startHour || entry.hour < p.endHour;
          }
        });
        if (!period) continue;

        const entryDate = new Date(entry.timestamp);
        let groupDate = new Date(entryDate);
        if (period.startHour > period.endHour && entry.hour < period.endHour) {
          groupDate.setDate(groupDate.getDate() - 1);
        }

        const y = groupDate.getFullYear();
        const m = String(groupDate.getMonth() + 1).padStart(2, "0");
        const d = String(groupDate.getDate()).padStart(2, "0");
        const dayIso = `${y}-${m}-${d}`;

        const today = new Date();
        const diffDays = Math.floor((groupDate - new Date(today.getFullYear(), today.getMonth(), today.getDate())) / (1000 * 60 * 60 * 24));

        let displayDate;
        if (diffDays === 0) {
          displayDate = "Heute";
        } else if (diffDays === 1) {
          displayDate = "Morgen";
        } else if (diffDays === 2) {
          displayDate = "√úbermorgen";
        } else {
          displayDate = groupDate.toLocaleDateString("de-DE", {
            weekday: "short",
            day: "2-digit",
            month: "short",
            timeZone: "Europe/Berlin"
          });
        }

        if (!daysMap[dayIso]) daysMap[dayIso] = { displayDate, groups: {} };
        if (!daysMap[dayIso].groups[period.name]) daysMap[dayIso].groups[period.name] = [];
        daysMap[dayIso].groups[period.name].push(entry);
      }

      const dayKeys = Object.keys(daysMap).sort();
      if (dayKeys.length === 0) {
        container.innerHTML = `<div class="no-data">Keine zuk√ºnftigen Vorhersagen vorhanden.</div>`;
        return;
      }


      // ********* Schritt 4: Aktuellen Tag finden *********
      const today = new Date();
      const ty = today.getFullYear();
      const tm = String(today.getMonth() + 1).padStart(2, "0");
      const td = String(today.getDate()).padStart(2, "0");
      const todayIso = `${ty}-${tm}-${td}`;

      const sortedKeys = Object.keys(daysMap).sort();
      let currentIndex = sortedKeys.findIndex(k => k === todayIso);
      if (currentIndex === -1) currentIndex = 0;


      let animating = false;
      // ********* Schritt 5: Rendering eines einzelnen Tages *********
      function updateDaySelector(index, direction = null) {
        // Verhindere neue Animationen w√§hrend eine l√§uft
        if (animating) return;

        const iso = sortedKeys[index];
        const displayText = daysMap[iso].displayDate;

        const newWrapper = document.createElement("div");
        newWrapper.className = "day-slide-wrapper";
        newWrapper.innerHTML = `<strong>${displayText}</strong>`;

        // Startposition des neuen Wrappers
        if (direction === "left") {
          newWrapper.style.transform = "translateX(100%)";
        } else if (direction === "right") {
          newWrapper.style.transform = "translateX(-100%)";
        } else {
          newWrapper.style.transform = "translateX(0)";
        }

        // Suche alten Wrapper (falls vorhanden)
        const oldWrapper = selector.querySelector(".day-slide-wrapper");

        if (!oldWrapper) {
          // erster Aufruf: einfach einf√ºgen
          selector.innerHTML = "";
          selector.appendChild(newWrapper);
          // Force reflow + sicherstellen, dass er bei 0 landet
          newWrapper.getBoundingClientRect();
          requestAnimationFrame(() => { newWrapper.style.transform = "translateX(0)"; });
          // Render + Pfeile
          renderDay(iso, direction);
          document.getElementById("day-left").disabled = index <= 0;
          document.getElementById("day-right").disabled = index >= sortedKeys.length - 1;
          return;
        }

        // Beide vorhanden -> parallele Animation (alt raus, neu rein)
        animating = true;

        // append new (beide sind absolute, also √ºberlappen sie)
        selector.appendChild(newWrapper);

        // Stelle sicher, dass beide einen Transition-Wert haben (CSS hat das, aber inline ist robust)
        oldWrapper.style.transition = "transform 0.3s ease";
        newWrapper.style.transition = "transform 0.3s ease";

        // Ausgangszust√§nde setzen + reflow, damit die Transition sp√§ter stattfindet
        oldWrapper.style.transform = "translateX(0)";
        oldWrapper.getBoundingClientRect();
        newWrapper.getBoundingClientRect();

        // Trigger: alter Wrapper f√§hrt raus, neuer f√§hrt rein
        const exitDir = direction === "left" ? "-100%" : "100%";
        oldWrapper.style.transform = `translateX(${exitDir})`;
        requestAnimationFrame(() => { newWrapper.style.transform = "translateX(0)"; });

        // Cleanup wenn neue Animation fertig ist
        const onNewEnd = () => {
          if (oldWrapper.parentNode === selector) selector.removeChild(oldWrapper);
          newWrapper.removeEventListener("transitionend", onNewEnd);
          animating = false;
        };
        newWrapper.addEventListener("transitionend", onNewEnd);

        // Render + Pfeile
        renderDay(iso, direction);
        document.getElementById("day-left").disabled = index <= 0;
        document.getElementById("day-right").disabled = index >= sortedKeys.length - 1;
      }


      // ********* Schritt 6: Einzeltag-Rendering *********
      function renderDay(iso) {
        container.innerHTML = "";
        const day = daysMap[iso];
        if (!day) {
          container.innerHTML = `<div class="no-data">Keine Daten f√ºr den gew√§hlten Tag.</div>`;
          return;
        }

        periodOrder.forEach(periodName => {
          const entries = day.groups[periodName];
          if (!entries || entries.length === 0) return;

          const freq = {};
          for (const e of entries) {
            if (!isNaN(e.code)) freq[e.code] = (freq[e.code] || 0) + 1;
          }

          let dominantCode = Object.entries(freq)
            .sort((a, b) => {
              const countDiff = b[1] - a[1];
              if (countDiff !== 0) return countDiff;
              return b[0] - a[0];
            })[0]?.[0];
          

          if ([0, 1, 2, 3].includes(Number(dominantCode))) {
            const indices = [];
            for (const e of entries) {
              if (!isNaN(e.index)) indices.push(e.index);
            }

            const cloud_covers = [];
            for (const i of indices) {
              if (!isNaN(seriesMap["Bew√∂lkung"]?.[i])) cloud_covers.push(seriesMap["Bew√∂lkung"][i]);  
            }

            if (cloud_covers.length === 0) {
              console.warn("Warnung: cloud_cover ist leer, Durchschnitt wird auf 0 gesetzt.");
            }

            const avg_cloud_cover = cloud_covers.length > 0
              ? cloud_covers.reduce((acc, val) => acc + val, 0) / cloud_covers.length
              : 0; // oder null

            if (avg_cloud_cover <= 20) {
              dominantCode = 0;
            } else if (avg_cloud_cover <= 50) {
              dominantCode = 1;
            } else if (avg_cloud_cover <= 80) {
              dominantCode = 2;
            } else {
              dominantCode = 3;
            }
          }

          const info = wwIconMap[dominantCode] || { icon: "unknown.png", label: "unbekannt" };

          const card = document.createElement("div");
          card.className = "summary-card";
          card.innerHTML = `
            <img src="icons/${info.icon}" alt="${info.label}">
            <div class="summary-text">
              <strong>${periodName}</strong>
              <span class="label">${info.label}</span>
            </div>
          `;
          container.appendChild(card);
        });

        if (container.children.length === 0) {
          container.innerHTML = `<div class="no-data">F√ºr diesen Tag liegen keine Vorhersagedaten vor.</div>`;
        }
      }

      // ********* Schritt 7: Event-Listener f√ºr Pfeile *********
      const leftBtn = document.getElementById("day-left");
      const rightBtn = document.getElementById("day-right");

      leftBtn.addEventListener("click", () => {
        if (animating || currentIndex <= 0) return;
        currentIndex--;
        updateDaySelector(currentIndex, "right");
      });

      rightBtn.addEventListener("click", () => {
        if (animating || currentIndex >= sortedKeys.length - 1) return;
        currentIndex++;
        updateDaySelector(currentIndex, "left");
      });


      // ********* Initialisierung *********
      updateDaySelector(currentIndex);

      // ********* Schritt 8: Swipe-Gesten *********
      let touchStartX = null;
      let touchEndX = null;

      const swipeThreshold = 50; // Mindestabstand f√ºr einen Swipe in px

      selector.addEventListener("touchstart", function (e) {
        touchStartX = e.changedTouches[0].screenX;
      }, false);

      selector.addEventListener("touchend", function (e) {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipeGesture();
      }, false);

      function handleSwipeGesture() {
        if (animating) return;
        if (touchStartX === null || touchEndX === null) return;
        const diffX = touchEndX - touchStartX;

        if (Math.abs(diffX) > swipeThreshold) {
          if (diffX < 0 && currentIndex < sortedKeys.length - 1) {
            currentIndex++;
            updateDaySelector(currentIndex, "left");
          } else if (diffX > 0 && currentIndex > 0) {
            currentIndex--;
            updateDaySelector(currentIndex, "right");
          }
        }

        touchStartX = null;
        touchEndX = null;
      }

    }




    async function parseKML(text) {
      const KMLNS = "http://www.opengis.net/kml/2.2";
      const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

      try {
        setStatus("Parse XML ‚Ä¶");
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");
        if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

        timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
        if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
        const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
        if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

        const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
        const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
        const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
        const coordsFormatted = coords.replace(/,/g, ', ');
        const coordParts = coords.split(',');  // ergibt z.‚ÄØB. ["9.88", " 49.83", " 220.2"]
        const height = coordParts[2]?.trim() ?? ""; // drittes Element ist die H√∂he
        stationEl.innerHTML = `<b>Station:</b> ${stationDesc} &nbsp; <b>H√∂he:</b> ${height} m √º. M. &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)} m`;

        const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
        seriesMap = {};

        setStatus("Get UV and PT data ‚Ä¶");
        // uv und pt holen und einf√ºgen
        try {
            result_uv_and_pt = await runForecastUvAndPt(userLat, userLon);
            console.log(result_uv_and_pt);
            seriesMap["Gef√ºhlte Temperatur"] = result_uv_and_pt["GFT"].map(wert => {
                const celsius = wert - 273.15;
                return Math.round(celsius * 10) / 10;
            });

            seriesMap["UV-Index"] = result_uv_and_pt["UVI"].map(wert => {
                return Math.round(wert * 10) / 10;  
            });

        } catch(e) {
            console.warn("Fehler beim Laden von UV-Index und Gef√ºhlter Temperatur:", e);
        }

        setStatus("Finishing Data ‚Ä¶");
        for (const fc of forecasts) {
          const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
          const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
          if (!elName || !valueNode) continue;

          const unit = elementUnitsMap[elName];
          const converter = unitConversionMap[unit];
          const values = valueNode.textContent.trim().split(/\s+/).map(v => {
            if (v === "-" || v === "") return null;
            const num = Number(v);
            if (!Number.isFinite(num)) return v;
            const converted = converter ? converter(num) : num;
            return Math.round(converted * 100) / 100;
          });

          const readableName = elementNamesMap[elName] || elName;
          seriesMap[readableName] = values.slice(0, timeSteps.length);
        }

        // In konsole Werte ausgeben
        console.log("Parsed series:", seriesMap); 

        // Kombiniere Werte mit ihren Fehlern
        for (const { value, error } of combinedParams) {
          if (seriesMap[value] && seriesMap[error]) {
            // Kopiere die Fehlerwerte
            seriesMap[value + "_error"] = seriesMap[error];
            // Fehler-Spalte l√∂schen (soll nicht im Dropdown auftauchen)
            delete seriesMap[error];
          }
        }

        // Spalten holen
        let cols = Object.keys(seriesMap);

        // Sortieren nach preferredOrder, alles was nicht drinsteht kommt hinten dran
        cols.sort((a, b) => {
          const ia = preferredOrder.indexOf(a);
          const ib = preferredOrder.indexOf(b);
          if (ia === -1 && ib === -1) return a.localeCompare(b); // beide nicht in Liste ‚Üí alphabetisch
          if (ia === -1) return 1; // a nicht drin ‚Üí nach hinten
          if (ib === -1) return -1; // b nicht drin ‚Üí nach hinten
          return ia - ib; // nach Reihenfolge in Liste
        });

        const wide = [];
        for (let i = 0; i < timeSteps.length; i++) {
          const row = { Zeit: fmtLocal(timeSteps[i]) };
          for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
          wide.push(row);
        }
        lastWide = wide;

        // Filtere die Spaltennamen (c), deren Originalk√ºrzel in der Blacklist stehen
        const filteredCols = cols.filter(c => {
          // Alle Fehlerwerte ausschlie√üen (Parameternamen, die auf _error enden)
          if (c.endsWith("_error")) return false;

          // Hole das original K√ºrzel aus elementNamesMap, falls vorhanden
          const originalKey = Object.keys(elementNamesMap).find(k => elementNamesMap[k] === c);
          // Wenn kein Mapping vorhanden, nimm den angezeigten Namen selbst als Fallback
          const key = originalKey || c;
          return !excludedElements.includes(key);
        });


        plotSel.innerHTML = filteredCols.map(c => {
        const selected = (c === "Temperature 2m above surface") ? "selected" : "";
        return `<option value="${c}" ${selected}>${c}</option>`;
        }).join("");
        plotSel.disabled = false;

        // Wenn Temperatur verf√ºgbar, plottet sie zuerst ‚Äì sonst erster Eintrag
        const defaultParam = filteredCols.includes("Temperature 2m above surface")
        ? "Temperature 2m above surface"
        : filteredCols[0];

        if (defaultParam) {
        renderPlot(defaultParam);
        }

        setStatus("Fertig!");
        buildSummary();

        setTimeout(() => {
          setStatus("");  // Versteckt das Status-Element
          document.getElementById("loadButton").style.display = "none";  // Versteckt den Button
        }, 0);

      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + err.message);
        stationEl.textContent = "";
      }
    }

    function fmtLocal(iso) {
      try {
        return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" });
      } catch {
        return iso;
      }
    }

    let currentParam = null;

    function renderPlot(param) {
      currentParam = param;

      if (!seriesMap[param]) {
        plotlyDiv.innerHTML = "<em>Keine Daten f√ºr diesen Parameter</em>";
        return;
      }

      // Fehlerbereich vorhanden?
      const hasError = !!seriesMap[param + "_error"];
      const traces = [];

      // Uv index plot
      if (param.includes("UV-Index")) {
        const day_strings = result_uv_and_pt["uvi_times"]
        const hours = result_uv_and_pt["UVH"]     // in 'hh' Format

        const timeStep_uv = day_strings.map((date, i) => {
            const newDate = new Date(date); // Kopie erstellen
            newDate.setUTCHours(hours[i], 0, 0, 0); // Nur UTC-Hours setzen
            return newDate;
        });

        const xData = timeStep_uv
        const yData = seriesMap[param].map(v => v == null ? null : v);


        // Linie in grau
        traces.push({
            x: xData,
            y: yData,
            type: "scatter",
            mode: "lines",
            line: { width: 2, shape: "spline", color: "rgb(102, 102, 102)" },
            connectgaps: true,
            hoverinfo: "skip",
            showlegend: false
        });

        // Marker anderem grau
        traces.push({
            x: xData,
            y: yData,
            type: "scatter",
            mode: "markers",
            marker: { size: 6, color: "rgb(68, 68, 68)" }, 
            name: param
        });

        const layout = {
        ...getLayout(param),
        shapes: [
            {
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 1,
            y0: 0,
            y1: 3,
            fillcolor: 'rgba(0, 255, 0, 0.2)', // gr√ºn
            line: { width: 0 }
            },
            {
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 1,
            y0: 3,
            y1: 6,
            fillcolor: 'rgba(255, 255, 0, 0.2)', // gelb
            line: { width: 0 }
            },
            {
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 1,
            y0: 6,
            y1: 8,
            fillcolor: 'rgba(255, 165, 0, 0.2)', // orange
            line: { width: 0 }
            },
            {
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 1,
            y0: 8,
            y1: 11,
            fillcolor: 'rgba(255, 0, 0, 0.2)', // rot
            line: { width: 0 }
            },
            {
            type: 'rect',
            xref: 'paper',
            yref: 'y',
            x0: 0,
            x1: 1,
            y0: 11,
            y1: 13,
            fillcolor: 'rgba(128, 0, 128, 0.2)', // lila
            line: { width: 0 }
            }
        ]
        };

        Plotly.newPlot(plotlyDiv, traces, layout, getConfig());

        return;
      }

      if (param.includes("Temperatur")) {
        const gft_time_step = result_uv_and_pt['gft_times']
        const gft_data = seriesMap["Gef√ºhlte Temperatur"];

        // Linie Gef√ºhlte Temperatur in rot
        traces.push({
            x: gft_time_step,
            y: gft_data,
            type: "scatter",
            mode: "lines",
            line: { width: 2, shape: "spline", color: "rgb(200, 0, 0)" },
            connectgaps: true,
            hoverinfo: "skip",
            showlegend: false
        });

        // Marker Gef√ºhlte Temperatur in rot
        traces.push({
            x: gft_time_step,
            y: gft_data,
            type: "scatter",
            mode: "markers",
            marker: { size: 6, color: "rgb(120, 0, 0)" }, 
            name: "Gef√ºhlte Temperatur"
        });

      }

      const xData = timeSteps.map(ts => new Date(ts));
      const yData = seriesMap[param].map(v => v == null ? null : v);


      if (hasError) {
        const errorData = seriesMap[param + "_error"];
        const yUpper = yData.map((v, i) => (v != null && errorData[i] != null) ? v + errorData[i] : null);
        const yLower = yData.map((v, i) => (v != null && errorData[i] != null) ? v - errorData[i] : null);

        // Fl√§che zwischen upper und lower in hellem Blau
        traces.push({
          x: [...xData, ...xData.slice().reverse()],
          y: [...yUpper, ...yLower.slice().reverse()],
          type: "scatter",
          mode: "lines",
          fill: "toself",
          fillcolor: "rgba(120, 120, 120, 0.2)", // Hellblau transparent
          line: { color: "transparent" },
          hoverinfo: "skip",
          showlegend: false,
          connectgaps: true,
          name: `${param} Fehlerbereich`
        });
      }

      // Linie in grau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "lines",
        line: { width: 2, shape: "spline", color: "rgb(102, 102, 102)" },
        connectgaps: true,
        name: param,
        hoverinfo: "skip",
        showlegend: false
      });

      // Marker anderem grau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "markers",
        marker: { size: 6, color: "rgb(68, 68, 68)" }, 
        name: param
      });

      Plotly.newPlot(plotlyDiv, traces, getLayout(param), getConfig());
    }



    // Hilfsfunktionen f√ºr Layout und Config
    function getLayout(param) {
    // Alle Zeitpunkte als Date-Objekte
    const xData = timeSteps.map(ts => new Date(ts));

    // Bereich: von erstem Zeitpunkt bis +72 Stunden
    let xRange = null;
    if (xData.length > 0) {
        const start = xData[0];
        const end = new Date(start.getTime() + 72 * 3600 * 1000);
        xRange = [start, end];
    }

    return {
        margin: { l: 50, r: 20, t: 30, b: 70 },
        xaxis: {
        title: "Zeit",
        automargin: true,
        range: xRange   // <-- Standard-Zoom
        },
        yaxis: { title: param, automargin: true },
        hovermode: "x",
        autosize: true,
        showlegend: false,
        dragmode: "pan"
    };
    }

    function getConfig() {
      return {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: [
          "toImage",
          "select2d",
          "lasso2d",
          "zoomIn2d",
          "zoomOut2d",
          "autoScale2d",
          "resetScale2d"
        ]
      };
    }



    plotSel.addEventListener("change", e => renderPlot(e.target.value));
  </script>
</body>
</html>
