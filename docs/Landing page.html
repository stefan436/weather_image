<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wetter von Stefan</title>

  <!-- Beide Styles einbinden -->
  <link rel="stylesheet" href="Hamburgermenu_design.css">
  <link rel="stylesheet" href="style_mosmix_L_vorhersage.css">

  <!-- JS für Mosmix -->
  <script src="elementNamesMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <!-- Navigation -->
  <header>
    <nav class="navbar">
      <a href="#" class="logo">Wetterinfo</a>
      <div class="hamburger-menu" id="hamburger-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <ul class="nav-links" id="nav-menu">
        <li><a href="Regenradar.html">RADVOR Bild</a></li>
        <li><a href="Regenradar_vorhersage.html">RV Radarkomposit (Nowcasting)</a></li>
        <li><a href="Aktuelle_Temperatur.html">Aktuelle Messwerte</a></li>
        <li><a href="mosmix_L_vorhersage.html">Sattelitenbild</a></li
      </ul>
    </nav>
  </header>

  <!-- Hauptinhalt -->
  <main style="padding: 24px;">
    <h1>Aktuelle Mosmix Vorhersage</h1>

    <div class="row">
      <button id="loadButton" class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
      <label for="plotSelect">Plot-Parameter:</label>
      <select id="plotSelect" disabled></select>
      <span id="status" class="badge">Bereit</span>
    </div>

    <div id="station" class="meta"></div>

    <div id="plot">
      <div id="plotTitle" class="plot-title"></div>
      <div id="plotlyDiv"></div>
    </div>
  </main>

  <!-- Hamburger-Skript -->
  <script src="Hamburgermenu_script.js"></script>

  <!-- Mosmix Script -->
  <script>

    // gewünschte Reihenfolge
    const preferredOrder = [
      "Temperature 2m above surface",
      "Total precipitation during the last hour consistent with significant weather",
      "Probability: Occurrence of precipitation within the last hour",
      "Duration of precipitation within the last hour",
      "Effective cloud cover", 
      "Visibility", 
      "Wind speed", 
      "Maximum wind gust within the last hour",
      "Wind direction",
      "Probability for fog within the last hour", 
      "Probability: Visibility below 1000m", 
      "Sunshine duration during the last Hour", 
      "Global Irradiance", 
      "Surface pressure, reduced"
    ];
  

    // Kürzel, die nicht im Dropdown auftauchen sollen
    const excludedElements = [
      "E_PPP", "E_Td", "FX3", "FX625", "FX640", "FX655", "FXh", "FXh25", "FXh40",
      "PSd00", "PSd30", "PSd60", "R101", "R102", "R103", "R105", "R107", "R110",
      "R120", "R130", "R150", "R600", "R602", "R610", "R650", "RRad1", "Rd00",
      "Rd02", "Rd10", "Rd50", "Rh00", "Rh02", "Rh10", "Rh50", "RR1o1", "RR1u1",
      "RR1w1", "RR3c", "RR6c", "RRdc", "RRhc", "RRL1c", "RRS1c", "RRS3c", "RSunD",
      "SunD", "SunD3", "T5cm", "Td", "TG", "TM", "W1W2", "WPc11", "WPc31", "WPc61",
      "WPcd1", "WPch1", "ww", "ww3", "wwC", "wwC6", "wwCh", "wwD", "wwD6", "wwDh",
      "wwF", "wwF6", "wwFh", "wwL", "wwL6", "wwLh", "wwM6", "wwMd", "wwMh", "wwP6",
      "wwPd", "wwPh", "wwS", "wwS6", "wwSh", "wwT", "wwT6", "wwTd", "wwTh", "wwZ",
      "wwZ6", "wwZh", "FXh55", "N05", "Nh", "Nl", "Nlm", "Nm", "PEvap", "TX", "TN", "N"
    ];
 
    // Kombinationen von Werten + ihren Fehlern
    const combinedParams = [
      { value: "Temperature 2m above surface", error: "Absolute error temperature 2m above surface" },
      { value: "Wind speed", error: "Absolute error wind speed 10m above surface" },
      { value: "Wind direction", error: "Absolute error wind direction" }
    ];

    let closest_station_id = null;
    let minDistance = Infinity;
    const statusEl = document.getElementById("status");
    const stationEl= document.getElementById("station");
    const plotSel  = document.getElementById("plotSelect");
    const plotTitle= document.getElementById("plotTitle");
    const plotlyDiv= document.getElementById("plotlyDiv");

    let lastWide = null;
    let seriesMap = {};
    let timeSteps = [];

    function setStatus(txt) {
      statusEl.textContent = txt;
      statusEl.style.display = txt ? "inline-block" : "none";
    }


    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = toRadians(lat1),
            φ2 = toRadians(lat2);
      const Δφ = toRadians(lat2 - lat1),
            Δλ = toRadians(lon2 - lon1);
      const a = Math.sin(Δφ / 2) ** 2 +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function renderStationChoices(stations) {
      // Überschrift + Container für die Buttons
      stationEl.innerHTML = `
        <div class="station-info">
          <b>Nächste Stationen gefunden:</b>
          <div class="station-choices"></div>
        </div>
      `;

      const container = stationEl.querySelector(".station-choices");

      stations.forEach(st => {
        const btn = document.createElement("button");
        btn.textContent = `${st.description} (${Math.round(st.distance)} m)`;
        btn.className = "btn station-btn";
        btn.onclick = () => {
          closest_station_id = st.station_id;
          minDistance = st.distance;
          setStatus(`Station ${st.station_id} gewählt – lade KMZ …`);
          loadMosmixData(st.station_id);
        };
        container.appendChild(btn);
      });
    }


    async function findNearestStation() {
      setStatus("Lade Stationsliste …");
      try {
        const response = await fetch('mosmix_stationen_coords.json');
        if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
        const data = await response.json();

        if (!navigator.geolocation) {
          setStatus('Geolocation wird nicht unterstützt.');
          return;
        }

        navigator.geolocation.getCurrentPosition(async position => {
          const userLat = position.coords.latitude;
          const userLon = position.coords.longitude;

          // Alle Stationen mit Distanz berechnen
          const stationsWithDist = data.map(row => {
            const lat = parseFloat(row.lat);
            const lon = parseFloat(row.lon);
            if (isNaN(lat) || isNaN(lon)) return null;
            const distance = haversineDistance(userLat, userLon, lat, lon);
            return { ...row, distance };
          }).filter(Boolean);

          // nach Distanz sortieren
          stationsWithDist.sort((a, b) => a.distance - b.distance);

          // Top 5
          const nearestFive = stationsWithDist.slice(0, 5);

          // Buttons rendern
          renderStationChoices(nearestFive);
        }, error => {
          setStatus('Fehler beim Standortzugriff: ' + error.message);
        });


      } catch (err) {
        setStatus('Fehler: ' + err.message);
      }
    }

    async function loadMosmixData(stationId) {
      try {
        const proxy = 'https://corsproxy.io/?';
        const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
        const url = proxy + encodeURIComponent(baseUrl);

        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
        const blob = await resp.blob();

        const zip = await JSZip.loadAsync(blob);
        const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
        if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
        const kmlText = await zip.files[kmlFile].async("string");

        parseKML(kmlText);
      } catch (err) {
        setStatus("Fehler: " + err.message);
      }
    }

    const unitConversionMap = {
      K: v => v - 273.15,
      "m/s": v => v * 3.6,
      Pa: v => v / 100,
      "kg/m2": v => v,
      "s": v => v / 60,
      "1std kJ/m2": v => v / 3.6,
      "3std kJ/m2": v => v / 10.8,
      "m": v => v,
      "Sichtweite m": v => v / 1000,
      "%": v => v,
      "-": v => v,
      "0°..360°": v => v
    };

    const elementUnitsMap = {
      TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
      FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
      DD: "0°..360°", E_DD: "0°..360°",
      PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
      RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
      Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
      VV: "Sichtweite m", H_BsC: "m",
      SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
    };

    function parseKML(text) {
      const KMLNS = "http://www.opengis.net/kml/2.2";
      const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

      try {
        setStatus("Parse XML …");
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");
        if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

        timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
        if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
        const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
        if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

        const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
        const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
        const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
        const coordsFormatted = coords.replace(/,/g, ', ');
        stationEl.innerHTML = `<b>Station:</b> ${stationName} — ${stationDesc} &nbsp; <b>Koordinaten:</b> ${coordsFormatted} &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)}`;

        const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
        seriesMap = {};

        for (const fc of forecasts) {
          const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
          const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
          if (!elName || !valueNode) continue;

          const unit = elementUnitsMap[elName];
          const converter = unitConversionMap[unit];
          const values = valueNode.textContent.trim().split(/\s+/).map(v => {
            if (v === "-" || v === "") return null;
            const num = Number(v);
            if (!Number.isFinite(num)) return v;
            const converted = converter ? converter(num) : num;
            return Math.round(converted * 100) / 100;
          });

          const readableName = elementNamesMap[elName] || elName;
          seriesMap[readableName] = values.slice(0, timeSteps.length);
        }

        // Kombiniere Werte mit ihren Fehlern
        for (const { value, error } of combinedParams) {
          if (seriesMap[value] && seriesMap[error]) {
            // Kopiere die Fehlerwerte
            seriesMap[value + "_error"] = seriesMap[error];
            // Fehler-Spalte löschen (soll nicht im Dropdown auftauchen)
            delete seriesMap[error];
          }
        }

        // Spalten holen
        let cols = Object.keys(seriesMap);

        // Sortieren nach preferredOrder, alles was nicht drinsteht kommt hinten dran
        cols.sort((a, b) => {
          const ia = preferredOrder.indexOf(a);
          const ib = preferredOrder.indexOf(b);
          if (ia === -1 && ib === -1) return a.localeCompare(b); // beide nicht in Liste → alphabetisch
          if (ia === -1) return 1; // a nicht drin → nach hinten
          if (ib === -1) return -1; // b nicht drin → nach hinten
          return ia - ib; // nach Reihenfolge in Liste
        });

        const wide = [];
        for (let i = 0; i < timeSteps.length; i++) {
          const row = { Zeit: fmtLocal(timeSteps[i]) };
          for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
          wide.push(row);
        }
        lastWide = wide;

        // Filtere die Spaltennamen (c), deren Originalkürzel in der Blacklist stehen
        const filteredCols = cols.filter(c => {
          // Alle Fehlerwerte ausschließen (Parameternamen, die auf _error enden)
          if (c.endsWith("_error")) return false;

          // Hole das original Kürzel aus elementNamesMap, falls vorhanden
          const originalKey = Object.keys(elementNamesMap).find(k => elementNamesMap[k] === c);
          // Wenn kein Mapping vorhanden, nimm den angezeigten Namen selbst als Fallback
          const key = originalKey || c;
          return !excludedElements.includes(key);
        });


        plotSel.innerHTML = filteredCols.map(c => {
        const selected = (c === "Temperature 2m above surface") ? "selected" : "";
        return `<option value="${c}" ${selected}>${c}</option>`;
        }).join("");
        plotSel.disabled = false;

        // Wenn Temperatur verfügbar, plottet sie zuerst – sonst erster Eintrag
        const defaultParam = filteredCols.includes("Temperature 2m above surface")
        ? "Temperature 2m above surface"
        : filteredCols[0];

        if (defaultParam) {
        renderPlot(defaultParam);
        }

        setStatus("Fertig!");
        setTimeout(() => {
          setStatus("");  // Versteckt das Status-Element
          document.getElementById("loadButton").style.display = "none";  // Versteckt den Button
        }, 1000);

      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + err.message);
        stationEl.textContent = "";
      }
    }

    function fmtLocal(iso) {
      try {
        return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" });
      } catch {
        return iso;
      }
    }

    let currentParam = null;

    function renderPlot(param) {
      currentParam = param;
      plotTitle.textContent = `Verlauf von ${param}`;

      if (!seriesMap[param]) {
        plotlyDiv.innerHTML = "<em>Keine Daten für diesen Parameter</em>";
        return;
      }

      const xData = timeSteps.map(ts => new Date(ts));
      const yData = seriesMap[param].map(v => v == null ? null : v);

      // Fehlerbereich vorhanden?
      const hasError = !!seriesMap[param + "_error"];
      const traces = [];

      if (hasError) {
        const errorData = seriesMap[param + "_error"];
        const yUpper = yData.map((v, i) => (v != null && errorData[i] != null) ? v + errorData[i] : null);
        const yLower = yData.map((v, i) => (v != null && errorData[i] != null) ? v - errorData[i] : null);

        // Fläche zwischen upper und lower in hellem Blau
        traces.push({
          x: [...xData, ...xData.slice().reverse()],
          y: [...yUpper, ...yLower.slice().reverse()],
          type: "scatter",
          mode: "lines",
          fill: "toself",
          fillcolor: "rgba(120, 120, 120, 0.2)", // Hellblau transparent
          line: { color: "transparent" },
          hoverinfo: "skip",
          showlegend: false,
          connectgaps: true,
          name: `${param} Fehlerbereich`
        });
      }

      // Linie in mittlerem Blau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "lines",
        line: { width: 2, shape: "spline", color: "rgb(102, 102, 102)" }, // kräftiges Blau
        connectgaps: true,
        name: param,
        showlegend: false
      });

      // Marker in dunklerem Blau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "markers",
        marker: { size: 6, color: "rgb(68, 68, 68)" }, // dunkleres Blau
        name: param
      });

      Plotly.newPlot(plotlyDiv, traces, getLayout(param), getConfig());
    }



    // Hilfsfunktionen für Layout und Config
    function getLayout(param) {
    // Alle Zeitpunkte als Date-Objekte
    const xData = timeSteps.map(ts => new Date(ts));

    // Bereich: von erstem Zeitpunkt bis +72 Stunden
    let xRange = null;
    if (xData.length > 0) {
        const start = xData[0];
        const end = new Date(start.getTime() + 72 * 3600 * 1000);
        xRange = [start, end];
    }

    return {
        margin: { l: 50, r: 20, t: 30, b: 70 },
        xaxis: {
        title: "Zeit",
        automargin: true,
        range: xRange   // <-- Standard-Zoom
        },
        yaxis: { title: param, automargin: true },
        hovermode: "x unified",
        autosize: true,
        showlegend: false,
        dragmode: "pan"
    };
    }

    function getConfig() {
      return {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: [
          "toImage",
          "select2d",
          "lasso2d",
          "zoomIn2d",
          "zoomOut2d",
          "autoScale2d",
          "resetScale2d"
        ]
      };
    }



    plotSel.addEventListener("change", e => renderPlot(e.target.value));
  </script>
</body>
</html>

