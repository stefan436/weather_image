<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wetter von Stefan</title>
  
  <!-- App Icon f√ºr iOS Homescreen -->
  <link rel="apple-touch-icon" href="app_icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Wetter von Stefan">


  <!-- Beide Styles einbinden -->
  <link rel="stylesheet" href="Hamburgermenu_design.css">
  <link rel="stylesheet" href="style_mosmix_L_vorhersage.css">

  <!-- JS f√ºr Mosmix -->
  <script src="elementNamesMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>
<body>
  <!-- Navigation -->
  <header>
    <nav class="navbar">
      <a href="#" class="logo">Wetterinfo</a>
      <div class="hamburger-menu" id="hamburger-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <ul class="nav-links" id="nav-menu">
        <li><a href="Regenradar.html">RADVOR Bild</a></li>
        <li><a href="Regenradar_vorhersage.html">RV Radarkomposit (Nowcasting)</a></li>
        <li><a href="Aktuelle_Temperatur.html">Aktuelle Messwerte</a></li>
        <li><a href="https://www.sat24.com/en-gb/country/de">Satellitenbild <span style="font-size: 0.8em;">üîó</span></a></li>

      </ul>
    </nav>
  </header>

  <!-- Hauptinhalt -->
  <main style="padding: 12px;">
    <h1>Aktuelle Mosmix Vorhersage</h1>

    <div class="row">
      <button id="loadButton" class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
      <label for="plotSelect"><b>Plot-Parameter:</b></label>
      <select id="plotSelect" disabled></select>
      <span id="status" class="badge">Bereit</span>
    </div>

    <div id="station" class="meta"></div>

    <section id="weather-summary" class="weather-summary">
      <div id="scroll-container" class="scroll-container"></div>
    </section>


    <div id="plot">
      <div id="plotlyDiv"></div>
    </div>

    
    <div class="row" style="margin-top: 20px;">
      <button id="reloadButton" class="btn" onclick="location.reload()">Seite neu laden</button>
    </div>

  </main>

  <!-- Hamburger-Skript -->
  <script src="Hamburgermenu_script.js"></script>

  <!-- Mosmix Script -->
  <script>

    const wwIconMap = {
      // Gewitter
      95: { icon: "thunderstorm.png", label: "Gewitter mit Regen/Schnee" },

      // gefrierender Spr√ºhregen/Regen
      57: { icon: "freezing-rain.png", label: "Starker gefrierender Spr√ºhregen" },
      56: { icon: "freezing-rain.png", label: "Leichter gefrierender Spr√ºhregen" },
      67: { icon: "freezing-rain.png", label: "Starker gefrierender Regen" },
      66: { icon: "freezing-rain.png", label: "Leichter gefrierender Regen" },

      // Schnee/Schneeschauer
      86: { icon: "snow.png", label: "Starker Schneeschauer" },
      85: { icon: "snow.png", label: "Leichter Schneeschauer" },
      84: { icon: "sleet.png", label: "Starker Schneeregenschauer" },
      83: { icon: "sleet.png", label: "Leichter Schneeregenschauer" },
      75: { icon: "snow.png", label: "Starker Schneefall" },
      73: { icon: "snow.png", label: "M√§√üiger Schneefall" },
      71: { icon: "snow.png", label: "Leichter Schneefall" },
      69: { icon: "sleet.png", label: "Starker Schneeregen" },
      68: { icon: "sleet.png", label: "Leichter Schneeregen" },

      // Regen/Schauer
      82: { icon: "rain.png", label: "Heftiger Regenschauer" },
      81: { icon: "rain.png", label: "Starker Regenschauer" },
      80: { icon: "rain.png", label: "Leichter Regenschauer" },
      65: { icon: "rain.png", label: "Starker Regen" },
      63: { icon: "rain.png", label: "M√§√üiger Regen" },
      61: { icon: "rain.png", label: "Leichter Regen" },

      // Spr√ºhregen
      55: { icon: "rain.png", label: "Starker Spr√ºhregen" },
      53: { icon: "rain.png", label: "M√§√üiger Spr√ºhregen" },
      51: { icon: "rain.png", label: "Leichter Spr√ºhregen" },

      // Nebel
      49: { icon: "fog.png", label: "Nebel mit Reif" },
      45: { icon: "fog.png", label: "Nebel" },

      // Bew√∂lkung
      3:  { icon: "clouds.png", label: "Bew√∂lkung zunehmend" },
      2:  { icon: "clouds.png", label: "Bew√∂lkung unver√§ndert" },
      1:  { icon: "clouds.png", label: "Bew√∂lkung abnehmend" },
      0:  { icon: "day-and-night.png", label: "Klarer Himmel" }
    };

    const periods = [
      { name: "Vormittag", startHour: 6,  endHour: 10 },
      { name: "Mittag",    startHour: 10, endHour: 14 },
      { name: "Nachmittag",startHour: 14, endHour: 18 },
      { name: "Abend",     startHour: 18, endHour: 22 },
      { name: "Nacht",     startHour: 22, endHour: 6 }
    ];



    // gew√ºnschte Reihenfolge
    const preferredOrder = [
      "Temperatur",
      "Niederschlagswahrscheinlichkeit",
      "Totale Niderschlagsmenge",
      "Niederschlagsdauer",
      "Gewitterwahrscheinlichkeit",
      "Bew√∂lkung", 
      "Sichtweite", 
      "Windgeschwindigkeit", 
      "Maximale Windb√∂e",
      "Windrichtung",
      "Nebelwahrscheinlichkeit", 
      "Wahrscheinlichkeit Sichtweite < 1km", 
      "Sonnenscheindauer", 
      "Strahlungsintensit√§t", 
      "reduzierter Oberfl√§chendruck"
    ];
  

    // K√ºrzel, die nicht im Dropdown auftauchen sollen
    const excludedElements = [
      "E_PPP", "E_Td", "FX3", "FX625", "FX640", "FX655", "FXh", "FXh25", "FXh40",
      "PSd00", "PSd30", "PSd60", "R101", "R102", "R103", "R105", "R107", "R110",
      "R120", "R130", "R150", "R600", "R602", "R610", "R650", "RRad1", "Rd00",
      "Rd02", "Rd10", "Rd50", "Rh00", "Rh02", "Rh10", "Rh50", "RR1o1", "RR1u1",
      "RR1w1", "RR3c", "RR6c", "RRdc", "RRhc", "RRL1c", "RRS1c", "RRS3c", "RSunD",
      "SunD", "SunD3", "T5cm", "Td", "TG", "TM", "W1W2", "WPc11", "WPc31", "WPc61",
      "WPcd1", "WPch1", "ww", "ww3", "wwC", "wwC6", "wwCh", "wwD", "wwD6", "wwDh",
      "wwF", "wwF6", "wwFh", "wwL", "wwL6", "wwLh", "wwM6", "wwMd", "wwMh", "wwP6",
      "wwPd", "wwPh", "wwS", "wwS6", "wwSh", "wwT6", "wwTd", "wwTh", "wwZ",
      "wwZ6", "wwZh", "FXh55", "N05", "Nh", "Nl", "Nlm", "Nm", "PEvap", "TX", "TN", "N"
    ];
 
    // Kombinationen von Werten + ihren Fehlern
    const combinedParams = [
      { value: "Temperatur", error: "Absolute error temperature 2m above surface" },
      { value: "Windgeschwindigkeit", error: "Absolute error wind speed 10m above surface" },
      { value: "Windrichtung", error: "Absolute error wind direction" }
    ];

    let closest_station_id = null;
    let minDistance = Infinity;
    const statusEl = document.getElementById("status");
    const stationEl= document.getElementById("station");
    const plotSel  = document.getElementById("plotSelect");
    const plotlyDiv= document.getElementById("plotlyDiv");

    let lastWide = null;
    let seriesMap = {};
    let timeSteps = [];

    function setStatus(txt) {
      statusEl.textContent = txt;
      statusEl.style.display = txt ? "inline-block" : "none";
    }


    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const œÜ1 = toRadians(lat1),
            œÜ2 = toRadians(lat2);
      const ŒîœÜ = toRadians(lat2 - lat1),
            ŒîŒª = toRadians(lon2 - lon1);
      const a = Math.sin(ŒîœÜ / 2) ** 2 +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function renderStationChoices(stations) {
      // √úberschrift + Container f√ºr die Buttons
      stationEl.innerHTML = `
        <div class="station-info">
          <b>N√§chste Stationen gefunden:</b>
          <div class="station-choices"></div>
        </div>
      `;

      const container = stationEl.querySelector(".station-choices");

      stations.forEach(st => {
        const btn = document.createElement("button");
        btn.textContent = `${st.description} (${Math.round(st.distance)} m)`;
        btn.className = "btn station-btn";
        btn.onclick = () => {
          closest_station_id = st.station_id;
          minDistance = st.distance;
          setStatus(`Station ${st.station_id} gew√§hlt ‚Äì lade KMZ ‚Ä¶`);
          loadMosmixData(st.station_id);
        };
        container.appendChild(btn);
      });
    }


    async function findNearestStation() {
      setStatus("Lade Stationsliste ‚Ä¶");
      try {
        const response = await fetch('mosmix_stationen_coords.json');
        if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
        const data = await response.json();

        if (!navigator.geolocation) {
          setStatus('Geolocation wird nicht unterst√ºtzt.');
          return;
        }

        navigator.geolocation.getCurrentPosition(async position => {
          const userLat = position.coords.latitude;
          const userLon = position.coords.longitude;

          // Alle Stationen mit Distanz berechnen
          const stationsWithDist = data.map(row => {
            const lat = parseFloat(row.lat);
            const lon = parseFloat(row.lon);
            if (isNaN(lat) || isNaN(lon)) return null;
            const distance = haversineDistance(userLat, userLon, lat, lon);
            return { ...row, distance };
          }).filter(Boolean);

          // nach Distanz sortieren
          stationsWithDist.sort((a, b) => a.distance - b.distance);

          // Top 5
          const nearestFive = stationsWithDist.slice(0, 5);

          // Buttons rendern
          renderStationChoices(nearestFive);
        }, error => {
          setStatus('Fehler beim Standortzugriff: ' + error.message);
        });


      } catch (err) {
        setStatus('Fehler: ' + err.message);
      }
    }

    async function loadMosmixData(stationId) {
      try {
        const proxy = 'https://corsproxy.io/?';
        const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
        const url = proxy + encodeURIComponent(baseUrl);

        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
        const blob = await resp.blob();

        const zip = await JSZip.loadAsync(blob);
        const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
        if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
        const kmlText = await zip.files[kmlFile].async("string");

        parseKML(kmlText);
      } catch (err) {
        setStatus("Fehler: " + err.message);
      }
    }

    const unitConversionMap = {
      K: v => v - 273.15,
      "m/s": v => v * 3.6,
      Pa: v => v / 100,
      "kg/m2": v => v,
      "s": v => v / 60,
      "1std kJ/m2": v => v / 3.6,
      "3std kJ/m2": v => v / 10.8,
      "m": v => v,
      "Sichtweite m": v => v / 1000,
      "%": v => v,
      "-": v => v,
      "0¬∞..360¬∞": v => v
    };

    const elementUnitsMap = {
      TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
      FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
      DD: "0¬∞..360¬∞", E_DD: "0¬∞..360¬∞",
      PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
      RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
      Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
      VV: "Sichtweite m", H_BsC: "m",
      SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
    };


    function buildSummary() {
      if (!seriesMap["Significant Weather"]) {
        console.warn("Kein Wettercode (ww) verf√ºgbar ‚Äì keine Zusammenfassung m√∂glich");
        return;
      }

      const container = document.getElementById("scroll-container");
      container.innerHTML = "";

      const now = new Date();

      const entries = timeSteps.map((ts, i) => {
        const dateObj = new Date(ts);
        const code = parseInt(seriesMap["Significant Weather"][i]);
        return {
          timestamp: dateObj,
          hour: dateObj.getHours(),
          dateStr: dateObj.toLocaleString("de-DE", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
            hour: "2-digit",
            minute: "2-digit"
          }),
          dateOnly: dateObj.toLocaleDateString("de-DE"),
          code
        };
      });

      // Gruppiere nach Datum + Zeitraum
      const grouped = {};

      for (const entry of entries) {
        const period = periods.find(p => {
          if (p.startHour < p.endHour) {
            return entry.hour >= p.startHour && entry.hour < p.endHour;
          } else {
            // Nacht (z.B. 22‚Äì6)
            return entry.hour >= p.startHour || entry.hour < p.endHour;
          }
        });

        if (!period) continue;

        const key = `${entry.dateOnly}_${period.name}`;
        if (!grouped[key]) {
          grouped[key] = {
            date: entry.dateOnly,
            periodName: period.name,
            entries: []
          };
        }
        grouped[key].entries.push(entry);
      }

      // Sortiere nach Datum, dann Perioden ‚Äì beginnend beim aktuellen Zeitraum
      const sortedKeys = Object.keys(grouped).sort((a, b) => {
        const [dateA, periodA] = a.split("_");
        const [dateB, periodB] = b.split("_");
        const dA = new Date(dateA.split(".").reverse().join("-"));
        const dB = new Date(dateB.split(".").reverse().join("-"));

        if (+dA !== +dB) return dA - dB;

        const nowHour = now.getHours();
        const periodOrder = periods.map(p => p.name);

        const shift = periodOrder.findIndex(p => {
          const pDef = periods.find(per => per.name === p);
          return (pDef.startHour <= nowHour && nowHour < pDef.endHour) ||
                (pDef.startHour > pDef.endHour && (nowHour >= pDef.startHour || nowHour < pDef.endHour));
        });

        const adjusted = [...periodOrder.slice(shift), ...periodOrder.slice(0, shift)];
        const ia = adjusted.indexOf(periodA);
        const ib = adjusted.indexOf(periodB);
        return ia - ib;
      });

      for (const key of sortedKeys) {
        const group = grouped[key];
        const freq = {};
        for (const e of group.entries) {
          if (!isNaN(e.code)) freq[e.code] = (freq[e.code] || 0) + 1;
        }

        const dominantCode = Object.entries(freq).sort((a, b) => b[1] - a[1])[0]?.[0];
        const info = wwIconMap[dominantCode] || { icon: "unknown.png", label: "unbekannt" };

        const card = document.createElement("div");
        card.className = "summary-card";
        card.innerHTML = `
          <img src="icons/${info.icon}" alt="${info.label}">
          <strong>${group.periodName}</strong>
          <span>${info.label}</span>
          <span>${group.date}</span>
        `;
        container.appendChild(card);
      }
    }


    function parseKML(text) {
      const KMLNS = "http://www.opengis.net/kml/2.2";
      const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

      try {
        setStatus("Parse XML ‚Ä¶");
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");
        if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

        timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
        if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
        const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
        if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

        const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
        const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
        const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
        const coordsFormatted = coords.replace(/,/g, ', ');
        const coordParts = coords.split(',');  // ergibt z.‚ÄØB. ["9.88", " 49.83", " 220.2"]
        const height = coordParts[2]?.trim() ?? ""; // drittes Element ist die H√∂he
        stationEl.innerHTML = `<b>Station:</b> ${stationDesc} &nbsp; <b>H√∂he:</b> ${height} m √º. M. &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)} m`;

        const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
        seriesMap = {};

        for (const fc of forecasts) {
          const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
          const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
          if (!elName || !valueNode) continue;

          const unit = elementUnitsMap[elName];
          const converter = unitConversionMap[unit];
          const values = valueNode.textContent.trim().split(/\s+/).map(v => {
            if (v === "-" || v === "") return null;
            const num = Number(v);
            if (!Number.isFinite(num)) return v;
            const converted = converter ? converter(num) : num;
            return Math.round(converted * 100) / 100;
          });

          const readableName = elementNamesMap[elName] || elName;
          seriesMap[readableName] = values.slice(0, timeSteps.length);
        }

        // In konsole Werte ausgeben
        console.log("Parsed series:", seriesMap); 

        // Kombiniere Werte mit ihren Fehlern
        for (const { value, error } of combinedParams) {
          if (seriesMap[value] && seriesMap[error]) {
            // Kopiere die Fehlerwerte
            seriesMap[value + "_error"] = seriesMap[error];
            // Fehler-Spalte l√∂schen (soll nicht im Dropdown auftauchen)
            delete seriesMap[error];
          }
        }

        // Spalten holen
        let cols = Object.keys(seriesMap);

        // Sortieren nach preferredOrder, alles was nicht drinsteht kommt hinten dran
        cols.sort((a, b) => {
          const ia = preferredOrder.indexOf(a);
          const ib = preferredOrder.indexOf(b);
          if (ia === -1 && ib === -1) return a.localeCompare(b); // beide nicht in Liste ‚Üí alphabetisch
          if (ia === -1) return 1; // a nicht drin ‚Üí nach hinten
          if (ib === -1) return -1; // b nicht drin ‚Üí nach hinten
          return ia - ib; // nach Reihenfolge in Liste
        });

        const wide = [];
        for (let i = 0; i < timeSteps.length; i++) {
          const row = { Zeit: fmtLocal(timeSteps[i]) };
          for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
          wide.push(row);
        }
        lastWide = wide;

        // Filtere die Spaltennamen (c), deren Originalk√ºrzel in der Blacklist stehen
        const filteredCols = cols.filter(c => {
          // Alle Fehlerwerte ausschlie√üen (Parameternamen, die auf _error enden)
          if (c.endsWith("_error")) return false;

          // Hole das original K√ºrzel aus elementNamesMap, falls vorhanden
          const originalKey = Object.keys(elementNamesMap).find(k => elementNamesMap[k] === c);
          // Wenn kein Mapping vorhanden, nimm den angezeigten Namen selbst als Fallback
          const key = originalKey || c;
          return !excludedElements.includes(key);
        });


        plotSel.innerHTML = filteredCols.map(c => {
        const selected = (c === "Temperature 2m above surface") ? "selected" : "";
        return `<option value="${c}" ${selected}>${c}</option>`;
        }).join("");
        plotSel.disabled = false;

        // Wenn Temperatur verf√ºgbar, plottet sie zuerst ‚Äì sonst erster Eintrag
        const defaultParam = filteredCols.includes("Temperature 2m above surface")
        ? "Temperature 2m above surface"
        : filteredCols[0];

        if (defaultParam) {
        renderPlot(defaultParam);
        }

        setStatus("Fertig!");
        buildSummary();

        setTimeout(() => {
          setStatus("");  // Versteckt das Status-Element
          document.getElementById("loadButton").style.display = "none";  // Versteckt den Button
        }, 1000);

      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + err.message);
        stationEl.textContent = "";
      }
    }

    function fmtLocal(iso) {
      try {
        return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" });
      } catch {
        return iso;
      }
    }

    let currentParam = null;

    function renderPlot(param) {
      currentParam = param;

      if (!seriesMap[param]) {
        plotlyDiv.innerHTML = "<em>Keine Daten f√ºr diesen Parameter</em>";
        return;
      }

      const xData = timeSteps.map(ts => new Date(ts));
      const yData = seriesMap[param].map(v => v == null ? null : v);

      // Fehlerbereich vorhanden?
      const hasError = !!seriesMap[param + "_error"];
      const traces = [];

      if (hasError) {
        const errorData = seriesMap[param + "_error"];
        const yUpper = yData.map((v, i) => (v != null && errorData[i] != null) ? v + errorData[i] : null);
        const yLower = yData.map((v, i) => (v != null && errorData[i] != null) ? v - errorData[i] : null);

        // Fl√§che zwischen upper und lower in hellem Blau
        traces.push({
          x: [...xData, ...xData.slice().reverse()],
          y: [...yUpper, ...yLower.slice().reverse()],
          type: "scatter",
          mode: "lines",
          fill: "toself",
          fillcolor: "rgba(120, 120, 120, 0.2)", // Hellblau transparent
          line: { color: "transparent" },
          hoverinfo: "skip",
          showlegend: false,
          connectgaps: true,
          name: `${param} Fehlerbereich`
        });
      }

      // Linie in mittlerem Blau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "lines",
        line: { width: 2, shape: "spline", color: "rgb(102, 102, 102)" }, // kr√§ftiges Blau
        connectgaps: true,
        name: param,
        showlegend: false
      });

      // Marker in dunklerem Blau
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "markers",
        marker: { size: 6, color: "rgb(68, 68, 68)" }, // dunkleres Blau
        name: param
      });

      Plotly.newPlot(plotlyDiv, traces, getLayout(param), getConfig());
    }



    // Hilfsfunktionen f√ºr Layout und Config
    function getLayout(param) {
    // Alle Zeitpunkte als Date-Objekte
    const xData = timeSteps.map(ts => new Date(ts));

    // Bereich: von erstem Zeitpunkt bis +72 Stunden
    let xRange = null;
    if (xData.length > 0) {
        const start = xData[0];
        const end = new Date(start.getTime() + 72 * 3600 * 1000);
        xRange = [start, end];
    }

    return {
        margin: { l: 50, r: 20, t: 30, b: 70 },
        xaxis: {
        title: "Zeit",
        automargin: true,
        range: xRange   // <-- Standard-Zoom
        },
        yaxis: { title: param, automargin: true },
        hovermode: "x unified",
        autosize: true,
        showlegend: false,
        dragmode: "pan"
    };
    }

    function getConfig() {
      return {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: [
          "toImage",
          "select2d",
          "lasso2d",
          "zoomIn2d",
          "zoomOut2d",
          "autoScale2d",
          "resetScale2d"
        ]
      };
    }



    plotSel.addEventListener("change", e => renderPlot(e.target.value));
  </script>
</body>
</html>
