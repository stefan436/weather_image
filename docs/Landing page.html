<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wetter von Stefan</title>
  
  <!-- App Icon fÃ¼r iOS Homescreen -->
  <link rel="apple-touch-icon" href="icons/app_icon.png">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Wetter von Stefan">


  <!-- Beide Styles einbinden -->
  <link rel="stylesheet" href="styles/Hamburgermenu_design.css">
  <link rel="stylesheet" href="styles/style_mosmix_L_vorhersage.css">

  <!-- JS fÃ¼r Mosmix -->
  <script src="scripts/elementNamesMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <!-- JS fÃ¼r uv und pt -->
   <script src="scripts/uv_and_pt_script.js"></script>

</head>
<body>
  <!-- Navigation -->
  <header>
    <nav class="navbar">
      <a href="#" class="logo">Wetterinfo</a>
      <div class="hamburger-menu" id="hamburger-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <ul class="nav-links" id="nav-menu">
        <li><a href="Regenradar.html">RADVOR Bild</a></li>
        <li><a href="Regenradar_vorhersage.html">RV Radarkomposit (Nowcasting)</a></li>
        <li><a href="Aktuelle_Temperatur.html">Aktuelle Messwerte</a></li>
        <li><a href="https://www.sat24.com/en-gb/country/de/hd">Satellitenbild <span style="font-size: 0.8em;">ðŸ”—</span></a></li>

      </ul>
    </nav>
  </header>

  <!-- Hauptinhalt -->
  <main style="padding: 12px;">
    <h1>Aktuelle MOSMIX Vorhersage</h1>

    <div class="row">
      <button id="loadButton" class="btn" onclick="findNearestStation()">Aktueller Standort</button>
      <div style="display: flex; gap: 0.5em;">
        <input type="text" id="address" placeholder="Gib Adresse ein" style="flex: 2; padding: 0.5em;">
        <button class='btn' id="addressButton" onclick="geocode()" style="flex: 1;">Suchen</button>
      </div>
      <div id="result"></div>
      <button id="confirmButton" class="btn" style="display: none;" onclick="confirmResult()">BestÃ¤tigen</button>
      <label for="plotSelect"><strong>Plot-Parameter:</strong></label>
      <select id="plotSelect" disabled></select>
      <span id="status" class="badge">Bereit</span>
    </div>

    <div id="station" class="meta"></div>

    <section id="weather-summary" class="weather-summary">

      <div class="day-selector-wrapper">
        <button class="day-arrow left" id="day-left">&#10094;</button>
        <div id="day-selector" class="day-selector"></div>
        <button class="day-arrow right" id="day-right">&#10095;</button>
      </div>

      <div id="scroll-container" class="scroll-container"></div>
    </section>




    <div id="plot">
      <div id="plotlyDiv"></div>
    </div>

    <div class="row" style="margin-top: 20px;">
      <span id="infoText" class="infoBadge">
        <strong>Hinweise:</strong> 
        <ul>
          <li>Die "GefÃ¼hlte Temperatur" und der "UV-Index" werden aus einer seperaten Datei (DWD) abgerufen und werden fÃ¼r den nÃ¤chstgelegenen Vorhersagepunkt zum Standort oder der Adresse angegeben.</li>
          <li>Die Zusammenfassung zeigt die dominierenden Wetterbedingungen (signifikanteste Wettersituation) fÃ¼r Nachts (2-6 Uhr), FrÃ¼hs (6-10 Uhr), Mittags (10-14 Uhr), Nachmittags (14-18 Uhr), Abends (18-22 Uhr) und SpÃ¤t Abends (22-02 Uhr).</li>
        </ul>
      </span>
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-content">
      <p>
        Alle Daten (auÃŸer anders Vermerkt) vom DWD (Quelle: Deutscher Wetterdienst), lizensiert unter <a class="footer-link" href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC BY 4.0</a>.<br>
        Daten ggf. bearbeitet.<br>
      </p>
      <p>
        Geocoding durch <a class="footer-link" href="https://nominatim.openstreetmap.org/">Nominatim</a> - Daten von <a class="footer-link" href="https://www.openstreetmap.org/">OpenStreetMap-Mitwirkende</a>
      </p>
      <a href="Impressum.html" class="footer-link">Impressum & Datenschutz</a>
      <a href="#" class="footer-link" onclick="location.reload(); return false;">Seite neu laden</a>
    </div>
  </footer>

  <!-- Hamburger-Skript -->
  <script src="scripts/Hamburgermenu_script.js"></script>

  <!-- Mosmix Script -->
  <script>
  Â  Â  const cache = new Map(); Â  Â  Â  Â // Einfacher Cache (Adresse â†’ Antwort)
  Â  Â  let lastRequestTime = 0; Â  Â  Â  Â // Zeit der letzten Anfrage (zum Limitieren)
  Â  Â  let lastData = null; Â  Â  Â  Â  Â  Â // Letztes Ergebnis speichern, um es bei BestÃ¤tigung zu nutzen
  Â  Â  let userLat = null;
  Â  Â  let userLon = null;
  Â  Â  let requestAdressData = null;

  Â  Â  async function geocode() {
  Â  Â  Â  Â  const address = document.getElementById("address").value;
  Â  Â  Â  Â  const resultDiv = document.getElementById("result");
  Â  Â  Â  Â  const confirmBtn = document.getElementById("confirmButton");

  Â  Â  Â  Â  confirmBtn.style.display = "none"; // BestÃ¤tigungsbutton ausblenden bei neuem Suchvorgang
  Â  Â  Â  Â  lastData = null;

  Â  Â  Â  Â  if (!address) {
  Â  Â  Â  Â  Â  Â  resultDiv.textContent = "Bitte gib eine Adresse ein.";
  Â  Â  Â  Â  Â  Â  return;
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // PrÃ¼fen, ob Ergebnis im Cache liegt
  Â  Â  Â  Â  if (cache.has(address)) {
  Â  Â  Â  Â  Â  Â  requestAdressData = cache.get(address);
  Â  Â  Â  Â  Â  Â  showResult(requestAdressData, resultDiv);
  Â  Â  Â  Â  Â  Â  lastData = requestAdressData[0];
  Â  Â  Â  Â  Â  Â  confirmBtn.style.display = "inline-block";
  Â  Â  Â  Â  Â  Â  console.log("Aus dem Cache geladen:", address);
  Â  Â  Â  Â  Â  Â  return;
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // Rate Limit prÃ¼fen
  Â  Â  Â  Â  const now = Date.now();
  Â  Â  Â  Â  const timeSinceLast = now - lastRequestTime;
  Â  Â  Â  Â  const delay = Math.max(0, 1000 - timeSinceLast); // mind. 1 Sekunde Abstand


  Â  Â  Â  Â  // VerzÃ¶gern, wenn nÃ¶tig
  Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, delay));
  Â  Â  Â  Â  lastRequestTime = Date.now(); // Jetzt ist diese Anfrage "aktiv"
        
          const proxy = 'https://cors-proxy-for-weather-app.stefan-wiedemann01.workers.dev?url=';
  Â  Â  Â  Â  const baseUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${address}`;
  Â  Â  Â    const url = proxy + encodeURIComponent(baseUrl);
        
  Â  Â  Â  Â  try {
  Â  Â  Â  Â  Â  Â  const response = await fetch(url, {
  Â  Â  Â  Â  Â  Â  Â  Â  headers: {
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Accept-Language": "de",
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "User-Agent": "wetterprojekt-stefan-2025 (https://stefan436.github.io/)"
  Â  Â  Â  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  Â  Â  });

  Â  Â  Â  Â  Â  Â  if (!response.ok) {
  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error("Fehler bei der Anfrage.");
  Â  Â  Â  Â  Â  Â  }

  Â  Â  Â  Â  Â  Â  requestAdressData = await response.json();
  Â  Â  Â  Â  Â  Â  cache.set(address, requestAdressData); // Zwischenspeichern

  Â  Â  Â  Â  Â  Â  showResult(requestAdressData, resultDiv);
  Â  Â  Â  Â  Â  Â  if(requestAdressData.length > 0) {
  Â  Â  Â  Â  Â  Â  Â  Â  lastData = requestAdressData[0];
  Â  Â  Â  Â  Â  Â  Â  Â  confirmBtn.style.display = "inline-block"; // Button anzeigen
  Â  Â  Â  Â  Â  Â  } else {
  Â  Â  Â  Â  Â  Â  Â  Â  confirmBtn.style.display = "none";
  Â  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  Â  Â  console.log("Cache-Inhalte:");
  Â  Â  Â  Â  Â  Â  for (const [adresse, daten] of cache.entries()) {
  Â  Â  Â  Â  Â  Â  Â  console.log(adresse, daten);
  Â  Â  Â  Â  Â  Â  }

  Â  Â  Â  Â  } catch (error) {
  Â  Â  Â  Â  Â  Â  resultDiv.textContent = "Fehler: " + error.message;
  Â  Â  Â  Â  Â  Â  confirmBtn.style.display = "none";
  Â  Â  Â  Â  }
  Â  Â  }

  Â  Â  function showResult(requestAdressData, resultDiv) {
  Â  Â  Â  Â  if (!requestAdressData || requestAdressData.length === 0) {
  Â  Â  Â  Â  Â  Â  resultDiv.textContent = "Keine Ergebnisse gefunden.";
  Â  Â  Â  Â  Â  Â  return;
  Â  Â  Â  Â  }

  Â  Â  Â  Â  const { lat, lon, display_name } = requestAdressData[0];
  Â  Â  Â  Â  resultDiv.innerHTML = `
  Â  Â  Â  Â  Â  Â  <strong>${display_name}</strong>
  Â  Â  Â  Â  `;
  Â  Â  }

  Â  Â  function confirmResult() {
  Â  Â  Â  Â  if (!lastData) return;
  Â  Â  Â  Â  const { lat, lon, display_name } = requestAdressData[0];
  Â  Â  Â  Â  userLat = lat
  Â  Â  Â  Â  userLon = lon

  Â  Â  Â  Â  setTimeout(() => {
  Â  Â  Â  Â  Â  setStatus(""); Â // Versteckt das Status-Element
  Â  Â  Â  Â  Â  document.getElementById("loadButton").style.display = "none"; Â // Versteckt den Button
  Â  Â  Â  Â  Â  document.getElementById("address").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("addressButton").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("result").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("confirmButton").style.display = "none";
  Â  Â  Â  Â  }, 0);

  Â  Â  Â  Â  findNearestStation()
  Â  Â  }

  Â  Â  const wwIconMap = {
  Â  Â  Â  // Gewitter
  Â  Â  Â  95: { icon: "thunderstorm.png", label: "Gewitter mit Regen/Schnee" },

  Â  Â  Â  // gefrierender SprÃ¼hregen/Regen
  Â  Â  Â  57: { icon: "heavy freeting rain.png", label: "Starker gefrierender SprÃ¼hregen" },
  Â  Â  Â  56: { icon: "light freezing rain.png", label: "Leichter gefrierender SprÃ¼hregen" },
  Â  Â  Â  67: { icon: "heavy freezing rain.png", label: "Starker gefrierender Regen" },
  Â  Â  Â  66: { icon: "light freezing rain.png", label: "Leichter gefrierender Regen" },

  Â  Â  Â  // Schnee/Schneeschauer
  Â  Â  Â  86: { icon: "heavy snow.png", label: "Starker Schneeschauer" },
  Â  Â  Â  85: { icon: "light snow.png", label: "Leichter Schneeschauer" },
  Â  Â  Â  84: { icon: "heavy sleet.png", label: "Starker Schneeregenschauer" },
  Â  Â  Â  83: { icon: "light sleet.png", label: "Leichter Schneeregenschauer" },
  Â  Â  Â  75: { icon: "heavy snow.png", label: "Starker Schneefall" },
  Â  Â  Â  73: { icon: "moderate snow.png", label: "MÃ¤ÃŸiger Schneefall" },
  Â  Â  Â  71: { icon: "light snow.png", label: "Leichter Schneefall" },
  Â  Â  Â  69: { icon: "heavy sleet.png", label: "Starker Schneeregen" },
  Â  Â  Â  68: { icon: "light sleet.png", label: "Leichter Schneeregen" },

  Â  Â  Â  // Regen/Schauer
  Â  Â  Â  82: { icon: "heavy rain.png", label: "Heftiger Regenschauer" },
  Â  Â  Â  81: { icon: "moderate rain.png", label: "Starker Regenschauer" },
  Â  Â  Â  80: { icon: "light rain.png", label: "Leichter Regenschauer" },
  Â  Â  Â  65: { icon: "heavy rain.png", label: "Starker Regen" },
  Â  Â  Â  63: { icon: "moderate rain.png", label: "MÃ¤ÃŸiger Regen" },
  Â  Â  Â  61: { icon: "light rain.png", label: "Leichter Regen" },

  Â  Â  Â  // SprÃ¼hregen
  Â  Â  Â  55: { icon: "heavy rain.png", label: "Starker SprÃ¼hregen" },
  Â  Â  Â  53: { icon: "moderate rain.png", label: "MÃ¤ÃŸiger SprÃ¼hregen" },
  Â  Â  Â  51: { icon: "light rain.png", label: "Leichter SprÃ¼hregen" },

  Â  Â  Â  // Nebel
  Â  Â  Â  49: { icon: "fog.png", label: "Nebel mit Reif" },
  Â  Â  Â  45: { icon: "fog.png", label: "Nebel" },

  Â  Â  Â  // BewÃ¶lkung
  Â  Â  Â  3: Â { icon: "total cloud cover.png", label: "BewÃ¶lkung zunehmend" },
  Â  Â  Â  2: Â { icon: "medium cloud cover.png", label: "BewÃ¶lkung unverÃ¤ndert" },
  Â  Â  Â  1: Â { icon: "low cloud cover.png", label: "BewÃ¶lkung abnehmend" },
  Â  Â  Â  0: Â { icon: "clear day.png", label: "Klarer Himmel" }
  Â  Â  };

      // NEU HINZUGEFÃœGT: Spezielle Icons fÃ¼r die Nacht
      const wwIconMapNight = {
          0: { icon: "clear night.png", label: "Klarer Himmel" },
          1: { icon: "low cloud cover night.png", label: "BewÃ¶lkung abnehmend" },
          2: { icon: "medium cloud cover night.png", label: "BewÃ¶lkung unverÃ¤ndert" }
      };

  Â  Â  // gewÃ¼nschte Reihenfolge
  Â  Â  const preferredOrder = [
  Â  Â  Â  "Temperatur",
  Â  Â  Â  "Niederschlagswahrscheinlichkeit",
  Â  Â  Â  "Totale Niederschlagsmenge",
  Â  Â  Â  "Gewitterwahrscheinlichkeit",
  Â  Â  Â  "BewÃ¶lkung", Â 
  Â  Â  Â  "Windgeschwindigkeit", 
  Â  Â  Â  "Maximale WindbÃ¶e",
  Â  Â  Â  "Windrichtung",
  Â  Â  Â  "Sichtweite",
  Â  Â  Â  "Nebelwahrscheinlichkeit", 
  Â  Â  Â  "Sonnenstunden-stÃ¼ndlich", 
  Â  Â  Â  "Sonnenstunden-tÃ¤glich",
  Â  Â  Â  "UV-Index",
  Â  Â  Â  "StrahlungsintensitÃ¤t", 
  Â  Â  Â  "reduzierter OberflÃ¤chendruck"
  Â  Â  ];


  Â  Â  // KÃ¼rzel, die nicht im Dropdown auftauchen sollen
  Â  Â  const excludedElements = [
  Â  Â  Â  "E_PPP", "E_Td", "FX3", "FX625", "FX640", "FX655", "FXh", "FXh25", "FXh40",
  Â  Â  Â  "PSd00", "PSd30", "PSd60", "R101", "R102", "R103", "R105", "R107", "R110",
  Â  Â  Â  "R120", "R130", "R150", "R600", "R602", "R610", "R650", "RRad1", "Rd00",
  Â  Â  Â  "Rd02", "Rd10", "Rd50", "Rh00", "Rh02", "Rh10", "Rh50", "RR1o1", "RR1u1",
  Â  Â  Â  "RR1w1", "RR3c", "RR6c", "RRdc", "RRhc", "RRL1c", "RRS1c", "RRS3c", "RSunD",
  Â  Â  Â  "SunD3", "T5cm", "Td", "TG", "TM", "W1W2", "WPc11", "WPc31", "WPc61", "DRR1",
  Â  Â  Â  "WPcd1", "WPch1", "ww", "ww3", "wwC", "wwC6", "wwCh", "wwD", "wwD6", "wwDh",
  Â  Â  Â  "wwF", "wwF6", "wwFh", "wwL", "wwL6", "wwLh", "wwM6", "wwMd", "wwMh", "wwP6",
  Â  Â  Â  "wwPd", "wwPh", "wwS", "wwS6", "wwSh", "wwT6", "wwTd", "wwTh", "wwZ", "VV10",
  Â  Â  Â  "wwZ6", "wwZh", "FXh55", "N05", "Nh", "Nl", "Nlm", "Nm", "PEvap", "TX", "TN", "N", "GefÃ¼hlte Temperatur"
  Â  Â  ];
  Â 
  Â  Â  // Kombinationen von Werten + ihren Fehlern
  Â  Â  const combinedParams = [
  Â  Â  Â  { value: "Temperatur", error: "Absolute error temperature 2m above surface" },
  Â  Â  Â  { value: "Windgeschwindigkeit", error: "Absolute error wind speed 10m above surface" },
  Â  Â  Â  { value: "Windrichtung", error: "Absolute error wind direction" }
  Â  Â  ];

  Â  Â  let closest_station_id = null;
  Â  Â  let minDistance = Infinity;
  Â  Â  let result_uv_and_pt = null;
  Â  Â  const statusEl = document.getElementById("status");
  Â  Â  const stationEl= document.getElementById("station");
  Â  Â  const plotSel Â = document.getElementById("plotSelect");
  Â  Â  const plotlyDiv= document.getElementById("plotlyDiv");

  Â  Â  let lastWide = null;
  Â  Â  let seriesMap = {};
  Â  Â  let timeSteps = [];

  Â  Â  function setStatus(txt) {
  Â  Â  Â  statusEl.textContent = txt;
  Â  Â  Â  statusEl.style.display = txt ? "inline-block" : "none";
  Â  Â  }


  Â  Â  function toRadians(deg) {
  Â  Â  Â  return deg * Math.PI / 180;
  Â  Â  }

  Â  Â  function haversineDistance(lat1, lon1, lat2, lon2) {
  Â  Â  Â  const R = 6371e3;
  Â  Â  Â  const Ï†1 = toRadians(lat1),
  Â  Â  Â  Â  Â  Â  Ï†2 = toRadians(lat2);
  Â  Â  Â  const Î”Ï† = toRadians(lat2 - lat1),
  Â  Â  Â  Â  Â  Â  Î”Î» = toRadians(lon2 - lon1);
  Â  Â  Â  const a = Math.sin(Î”Ï† / 2) ** 2 +
  Â  Â  Â  Â  Â  Â  Â  Â  Math.cos(Ï†1) * Math.cos(Ï†2) *
  Â  Â  Â  Â  Â  Â  Â  Â  Math.sin(Î”Î» / 2) ** 2;
  Â  Â  Â  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  Â  Â  }

  Â  Â  function renderStationChoices(stations) {
  Â  Â  Â  // Ãœberschrift + Container fÃ¼r die Buttons
  Â  Â  Â  stationEl.innerHTML = `
  Â  Â  Â  Â  <div class="station-info">
  Â  Â  Â  Â  Â  <b>NÃ¤chste Stationen gefunden:</b>
  Â  Â  Â  Â  Â  <div class="station-choices"></div>
  Â  Â  Â  Â  </div>
  Â  Â  Â  `;

  Â  Â  Â  const container = stationEl.querySelector(".station-choices");

  Â  Â  Â  stations.forEach(st => {
  Â  Â  Â  Â  const btn = document.createElement("button");
  Â  Â  Â  Â  btn.textContent = `${st.description} (${Math.round(st.distance)} m)`;
  Â  Â  Â  Â  btn.className = "btn station-btn";
  Â  Â  Â  Â  btn.onclick = () => {
  Â  Â  Â  Â  Â  closest_station_id = st.station_id;
  Â  Â  Â  Â  Â  minDistance = st.distance;
  Â  Â  Â  Â  Â  setStatus(`Station ${st.station_id} gewÃ¤hlt â€“ lade KMZ â€¦`);
  Â  Â  Â  Â  Â  loadMosmixData(st.station_id);
  Â  Â  Â  Â  };
  Â  Â  Â  Â  container.appendChild(btn);
  Â  Â  Â  });
  Â  Â  }

  Â  Â  function processWithUserCoords(lat, lon, stationData) {
  Â  Â  Â  Â  // Alle Stationen mit Distanz berechnen
  Â  Â  Â  Â  const stationsWithDist = stationData.map(row => {
  Â  Â  Â  Â  Â  Â  const stationLat = parseFloat(row.lat);
  Â  Â  Â  Â  Â  Â  const stationLon = parseFloat(row.lon);
  Â  Â  Â  Â  Â  Â  if (isNaN(stationLat) || isNaN(stationLon)) return null;
  Â  Â  Â  Â  Â  Â  const distance = haversineDistance(lat, lon, stationLat, stationLon);
  Â  Â  Â  Â  Â  Â  return { ...row, distance };
  Â  Â  Â  Â  }).filter(Boolean);

  Â  Â  Â  Â  // nach Distanz sortieren
  Â  Â  Â  Â  stationsWithDist.sort((a, b) => a.distance - b.distance);

  Â  Â  Â  Â  // Top 5
  Â  Â  Â  Â  const nearestFive = stationsWithDist.slice(0, 5);

  Â  Â  Â  Â  // Buttons rendern
  Â  Â  Â  Â  renderStationChoices(nearestFive);
  Â  Â  }


  Â  Â  async function findNearestStation() {
  Â  Â  Â  Â  setStatus("Lade Stationsliste â€¦");

  Â  Â  Â  Â  try {
  Â  Â  Â  Â  Â  Â  const response = await fetch('data/mosmix_stationen_coords.json');
  Â  Â  Â  Â  Â  Â  if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
  Â  Â  Â  Â  Â  Â  const data = await response.json();

  Â  Â  Â  Â  Â  Â  // PrÃ¼fen, ob Koordinaten bereits bekannt
  Â  Â  Â  Â  Â  Â  if (userLat !== null && userLon !== null) {
  Â  Â  Â  Â  Â  Â  Â  Â  // Bereits vorhanden â†’ direkt verwenden
  Â  Â  Â  Â  Â  Â  Â  Â  processWithUserCoords(userLat, userLon, data);
  Â  Â  Â  Â  Â  Â  } else {
  Â  Â  Â  Â  Â  Â  Â  Â  // Nicht vorhanden â†’ Geolocation anfragen
  Â  Â  Â  Â  Â  Â  Â  Â  if (!navigator.geolocation) {
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setStatus('Geolocation wird nicht unterstÃ¼tzt.');
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
  Â  Â  Â  Â  Â  Â  Â  Â  }

  Â  Â  Â  Â  Â  Â  Â  Â  navigator.geolocation.getCurrentPosition(
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  position => {
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userLat = position.coords.latitude;
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userLon = position.coords.longitude;
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  processWithUserCoords(userLat, userLon, data);
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  error => {
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setStatus('Fehler beim Standortzugriff: ' + error.message);
  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  Â  Â  Â  Â  );
  Â  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  } catch (err) {
  Â  Â  Â  Â  Â  Â  setStatus('Fehler: ' + err.message);
  Â  Â  Â  Â  }
  Â  Â  }


  Â  Â  async function loadMosmixData(stationId) {
  Â  Â  Â  try {
  Â  Â  Â  Â  const proxy = 'https://cors-proxy-for-weather-app.stefan-wiedemann01.workers.dev?url=';
  Â  Â  Â  Â  const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
  Â  Â  Â  Â  const url = proxy + encodeURIComponent(baseUrl);

  Â  Â  Â  Â  const resp = await fetch(url);
  Â  Â  Â  Â  if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
  Â  Â  Â  Â  const blob = await resp.blob();

  Â  Â  Â  Â  const zip = await JSZip.loadAsync(blob);
  Â  Â  Â  Â  const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
  Â  Â  Â  Â  if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
  Â  Â  Â  Â  const kmlText = await zip.files[kmlFile].async("string");

  Â  Â  Â  Â  parseKML(kmlText);
  Â  Â  Â  } catch (err) {
  Â  Â  Â  Â  setStatus("Fehler: " + err.message);
  Â  Â  Â  }
  Â  Â  }

  Â  Â  const unitConversionMap = {
  Â  Â  Â  K: v => v - 273.15,
  Â  Â  Â  "m/s": v => v * 3.6,
  Â  Â  Â  Pa: v => v / 100,
  Â  Â  Â  "kg/m2": v => v,
  Â  Â  Â  "s": v => v / 60,
  Â  Â  Â  "1std kJ/m2": v => v / 3.6,
  Â  Â  Â  "3std kJ/m2": v => v / 10.8,
  Â  Â  Â  "m": v => v,
  Â  Â  Â  "Sichtweite m": v => v / 1000,
  Â  Â  Â  "%": v => v,
  Â  Â  Â  "-": v => v,
  Â  Â  Â  "0Â°..360Â°": v => v
  Â  Â  };

  Â  Â  const elementUnitsMap = {
  Â  Â  Â  TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
  Â  Â  Â  FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
  Â  Â  Â  DD: "0Â°..360Â°", E_DD: "0Â°..360Â°",
  Â  Â  Â  PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
  Â  Â  Â  RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
  Â  Â  Â  Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
  Â  Â  Â  VV: "Sichtweite m", H_BsC: "m",
  Â  Â  Â  SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
  Â  Â  };


  Â  Â  // periods; Die Vorhersage fÃ¼r das signifikante Wetter vorhergesagt um 7 uhr bedeutet das Wetter zwischen 6:00 und 6.59 Uhr (within last hour)
  Â  Â  const periods = [
  Â  Â  Â  { name: "FrÃ¼h", startHour: 6, Â endHour: 10 },
  Â  Â  Â  { name: "Mittag", Â  Â startHour: 10, endHour: 14 },
  Â  Â  Â  { name: "Nachmittag" ,startHour: 14, endHour: 18 },
  Â  Â  Â  { name: "Abend", Â  Â  startHour: 18, endHour: 22 },
  Â  Â  Â  { name: "SpÃ¤t Abends", startHour:22, endHour:2 },
  Â  Â  Â  { name: "Nacht", Â  Â  startHour: 2, endHour: 6 }
  Â  Â  ];

  Â  Â  const periodOrder = ["Nacht", "FrÃ¼h", "Mittag", "Nachmittag", "Abend", "SpÃ¤t Abends"];

  Â  Â  /**
  Â  Â  * buildSummary: erstellt die Tag-Auswahl und rendert beim Klick die Summary-Karten
  Â  Â  * BenÃ¶tigt global: timeSteps (Array), seriesMap["Significant Weather"] (Array gleicher LÃ¤nge), wwIconMap (Objekt)
  Â  Â  */
  Â  Â  function buildSummary() {
  Â  Â  Â  if (!seriesMap || !seriesMap["Significant Weather"]) {
  Â  Â  Â  Â  console.warn("Kein Wettercode (ww) verfÃ¼gbar â€“ keine Zusammenfassung mÃ¶glich");
  Â  Â  Â  Â  return;
  Â  Â  Â  }

  Â  Â  Â  const container = document.getElementById("scroll-container");
  Â  Â  Â  const selector = document.getElementById("day-selector");
  Â  Â  Â  container.innerHTML = "";
  Â  Â  Â  selector.innerHTML = "";

  Â  Â  Â  const now = new Date();
  Â  Â  Â  now.setMinutes(0, 0, 0); // Minuten, Sekunden, Millisekunden auf 0 setzen

  Â  Â  Â  // ********* Schritt 1: Roh-EintrÃ¤ge vorbereiten *********
  Â  Â  Â  const entries = timeSteps.map((ts, i) => {
  Â  Â  Â  Â  const dateObj = new Date(ts);
  Â  Â  Â  Â  const code = parseInt(seriesMap["Significant Weather"][i]);
  Â  Â  Â  Â  return { timestamp: dateObj, hour: dateObj.getHours(), code, index: i };
  Â  Â  Â  });

  Â  Â  Â  // ********* Schritt 2: nur zukÃ¼nftige EintrÃ¤ge (ab jetzt) *********
  Â  Â  Â  const futureEntries = entries.filter(e => e.timestamp >= now);

  Â  Â  Â  // ********* Schritt 3: nach Tag (ISO YYYY-MM-DD) und Periode gruppieren *********
  Â  Â  Â  const daysMap = {};

  Â  Â  Â  for (const entry of futureEntries) {
  Â  Â  Â  Â  const period = periods.find(p => {
  Â  Â  Â  Â  Â  if (p.startHour < p.endHour) {
  Â  Â  Â  Â  Â  Â  return entry.hour >= p.startHour && entry.hour < p.endHour;
  Â  Â  Â  Â  Â  } else {
  Â  Â  Â  Â  Â  Â  return entry.hour >= p.startHour || entry.hour < p.endHour;
  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  });
  Â  Â  Â  Â  if (!period) continue;

  Â  Â  Â  Â  const entryDate = new Date(entry.timestamp);
  Â  Â  Â  Â  let groupDate = new Date(entryDate);
  Â  Â  Â  Â  if (period.startHour > period.endHour && entry.hour < period.endHour) {
  Â  Â  Â  Â  Â  groupDate.setDate(groupDate.getDate() - 1);
  Â  Â  Â  Â  }

  Â  Â  Â  Â  const y = groupDate.getFullYear();
  Â  Â  Â  Â  const m = String(groupDate.getMonth() + 1).padStart(2, "0");
  Â  Â  Â  Â  const d = String(groupDate.getDate()).padStart(2, "0");
  Â  Â  Â  Â  const dayIso = `${y}-${m}-${d}`;

  Â  Â  Â  Â  const today = new Date();
  Â  Â  Â  Â  const diffDays = Math.floor((groupDate - new Date(today.getFullYear(), today.getMonth(), today.getDate())) / (1000 * 60 * 60 * 24));

  Â  Â  Â  Â  let displayDate;
  Â  Â  Â  Â  if (diffDays === 0) {
  Â  Â  Â  Â  Â  displayDate = "Heute";
  Â  Â  Â  Â  } else if (diffDays === 1) {
  Â  Â  Â  Â  Â  displayDate = "Morgen";
  Â  Â  Â  Â  } else if (diffDays === 2) {
  Â  Â  Â  Â  Â  displayDate = "Ãœbermorgen";
  Â  Â  Â  Â  } else {
  Â  Â  Â  Â  Â  displayDate = groupDate.toLocaleDateString("de-DE", {
  Â  Â  Â  Â  Â  Â  weekday: "short",
  Â  Â  Â  Â  Â  Â  day: "2-digit",
  Â  Â  Â  Â  Â  Â  month: "short",
  Â  Â  Â  Â  Â  Â  timeZone: "Europe/Berlin"
  Â  Â  Â  Â  Â  });
  Â  Â  Â  Â  }

  Â  Â  Â  Â  if (!daysMap[dayIso]) daysMap[dayIso] = { displayDate, groups: {} };
  Â  Â  Â  Â  if (!daysMap[dayIso].groups[period.name]) daysMap[dayIso].groups[period.name] = [];
  Â  Â  Â  Â  daysMap[dayIso].groups[period.name].push(entry);
  Â  Â  Â  }

  Â  Â  Â  const dayKeys = Object.keys(daysMap).sort();
  Â  Â  Â  if (dayKeys.length === 0) {
  Â  Â  Â  Â  container.innerHTML = `<div class="no-data">Keine zukÃ¼nftigen Vorhersagen vorhanden.</div>`;
  Â  Â  Â  Â  return;
  Â  Â  Â  }


  Â  Â  Â  // ********* Schritt 4: Aktuellen Tag finden *********
  Â  Â  Â  const today = new Date();
  Â  Â  Â  const ty = today.getFullYear();
  Â  Â  Â  const tm = String(today.getMonth() + 1).padStart(2, "0");
  Â  Â  Â  const td = String(today.getDate()).padStart(2, "0");
  Â  Â  Â  const todayIso = `${ty}-${tm}-${td}`;

  Â  Â  Â  const sortedKeys = Object.keys(daysMap).sort();
  Â  Â  Â  let currentIndex = sortedKeys.findIndex(k => k === todayIso);
  Â  Â  Â  if (currentIndex === -1) currentIndex = 0;


  Â  Â  Â  let animating = false;
  Â  Â  Â  // ********* Schritt 5: Rendering eines einzelnen Tages *********
  Â  Â  Â  function updateDaySelector(index, direction = null) {
  Â  Â  Â  Â  // Verhindere neue Animationen wÃ¤hrend eine lÃ¤uft
  Â  Â  Â  Â  if (animating) return;

  Â  Â  Â  Â  const iso = sortedKeys[index];
  Â  Â  Â  Â  const displayText = daysMap[iso].displayDate;

  Â  Â  Â  Â  const newWrapper = document.createElement("div");
  Â  Â  Â  Â  newWrapper.className = "day-slide-wrapper";
  Â  Â  Â  Â  newWrapper.innerHTML = `<strong>${displayText}</strong>`;

  Â  Â  Â  Â  // Startposition des neuen Wrappers
  Â  Â  Â  Â  if (direction === "left") {
  Â  Â  Â  Â  Â  newWrapper.style.transform = "translateX(100%)";
  Â  Â  Â  Â  } else if (direction === "right") {
  Â  Â  Â  Â  Â  newWrapper.style.transform = "translateX(-100%)";
  Â  Â  Â  Â  } else {
  Â  Â  Â  Â  Â  newWrapper.style.transform = "translateX(0)";
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // Suche alten Wrapper (falls vorhanden)
  Â  Â  Â  Â  const oldWrapper = selector.querySelector(".day-slide-wrapper");

  Â  Â  Â  Â  if (!oldWrapper) {
  Â  Â  Â  Â  Â  // erster Aufruf: einfach einfÃ¼gen
  Â  Â  Â  Â  Â  selector.innerHTML = "";
  Â  Â  Â  Â  Â  selector.appendChild(newWrapper);
  Â  Â  Â  Â  Â  // Force reflow + sicherstellen, dass er bei 0 landet
  Â  Â  Â  Â  Â  newWrapper.getBoundingClientRect();
  Â  Â  Â  Â  Â  requestAnimationFrame(() => { newWrapper.style.transform = "translateX(0)"; });
  Â  Â  Â  Â  Â  // Render + Pfeile
  Â  Â  Â  Â  Â  renderDay(iso, direction);
  Â  Â  Â  Â  Â  document.getElementById("day-left").disabled = index <= 0;
  Â  Â  Â  Â  Â  document.getElementById("day-right").disabled = index >= sortedKeys.length - 1;
  Â  Â  Â  Â  Â  return;
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // Beide vorhanden -> parallele Animation (alt raus, neu rein)
  Â  Â  Â  Â  animating = true;

  Â  Â  Â  Â  // append new (beide sind absolute, also Ã¼berlappen sie)
  Â  Â  Â  Â  selector.appendChild(newWrapper);

  Â  Â  Â  Â  // Stelle sicher, dass beide einen Transition-Wert haben (CSS hat das, aber inline ist robust)
  Â  Â  Â  Â  oldWrapper.style.transition = "transform 0.3s ease";
  Â  Â  Â  Â  newWrapper.style.transition = "transform 0.3s ease";

  Â  Â  Â  Â  // AusgangszustÃ¤nde setzen + reflow, damit die Transition spÃ¤ter stattfindet
  Â  Â  Â  Â  oldWrapper.style.transform = "translateX(0)";
  Â  Â  Â  Â  oldWrapper.getBoundingClientRect();
  Â  Â  Â  Â  newWrapper.getBoundingClientRect();

  Â  Â  Â  Â  // Trigger: alter Wrapper fÃ¤hrt raus, neuer fÃ¤hrt rein
  Â  Â  Â  Â  const exitDir = direction === "left" ? "-100%" : "100%";
  Â  Â  Â  Â  oldWrapper.style.transform = `translateX(${exitDir})`;
  Â  Â  Â  Â  requestAnimationFrame(() => { newWrapper.style.transform = "translateX(0)"; });

  Â  Â  Â  Â  // Cleanup wenn neue Animation fertig ist
  Â  Â  Â  Â  const onNewEnd = () => {
  Â  Â  Â  Â  Â  if (oldWrapper.parentNode === selector) selector.removeChild(oldWrapper);
  Â  Â  Â  Â  Â  newWrapper.removeEventListener("transitionend", onNewEnd);
  Â  Â  Â  Â  Â  animating = false;
  Â  Â  Â  Â  };
  Â  Â  Â  Â  newWrapper.addEventListener("transitionend", onNewEnd);

  Â  Â  Â  Â  // Render + Pfeile
  Â  Â  Â  Â  renderDay(iso, direction);
  Â  Â  Â  Â  document.getElementById("day-left").disabled = index <= 0;
  Â  Â  Â  Â  document.getElementById("day-right").disabled = index >= sortedKeys.length - 1;
  Â  Â  Â  }


        // ********* Schritt 6: Einzeltag-Rendering *********
        function renderDay(iso) {
          container.innerHTML = "";
          const day = daysMap[iso];

          if (!day) {
            container.innerHTML = `<div class="no-data">Keine Daten fÃ¼r den gewÃ¤hlten Tag.</div>`;
            return;
          }

          periodOrder.forEach(periodName => {
            const entries = day.groups[periodName];
            if (!entries || entries.length === 0) return;

            const freq = {};
            for (const e of entries) {
              if (!isNaN(e.code)) freq[e.code] = (freq[e.code] || 0) + 1;
            }

            let dominantCode = Math.max(...entries.map(e => Number(e.code)));

            if ([0, 1, 2, 3].includes(Number(dominantCode))) {
              const indices = [];
              for (const e of entries) {
                if (!isNaN(e.index)) indices.push(e.index);
              }

              const cloud_covers = [];
              for (const i of indices) {
                if (!isNaN(seriesMap["BewÃ¶lkung"]?.[i])) {
                  cloud_covers.push(seriesMap["BewÃ¶lkung"][i]);
                }
              }

              if (cloud_covers.length === 0) {
                console.warn("Warnung: cloud_cover ist leer, Durchschnitt wird auf 0 gesetzt.");
              }

              const avg_cloud_cover = cloud_covers.length > 0
                ? cloud_covers.reduce((acc, val) => acc + val, 0) / cloud_covers.length
                : 0;

              if (avg_cloud_cover <= 20) {
                dominantCode = 0;
              } else if (avg_cloud_cover <= 50) {
                dominantCode = 1;
              } else if (avg_cloud_cover <= 80) {
                dominantCode = 2;
              } else {
                dominantCode = 3;
              }
            }

            // GEÃ„NDERT: WÃ¤hle das Icon-Set basierend auf der Tageszeit
            let info;
            const isNightPeriod = ["Abend", "SpÃ¤t Abends", "Nacht"].includes(periodName);

            if (isNightPeriod && [0, 1, 2].includes(dominantCode)) {
              info = wwIconMapNight[dominantCode] || { icon: "unknown.png", label: "unbekannt" };
            } else {
              info = wwIconMap[dominantCode] || { icon: "unknown.png", label: "unbekannt" };
            }

            const card = document.createElement("div");
            card.className = "summary-card";
            card.innerHTML = `
              <img src="icons/${info.icon}" alt="${info.label}">
              <div class="summary-text">
                <strong>${periodName}</strong>
                <span class="label">${info.label}</span>
              </div>
            `;
            container.appendChild(card);
          });

          if (container.children.length === 0) {
            container.innerHTML = `<div class="no-data">FÃ¼r diesen Tag liegen keine Vorhersagedaten vor.</div>`;
          }
        }

  Â  Â  Â  // ********* Schritt 7: Event-Listener fÃ¼r Pfeile *********
  Â  Â  Â  const leftBtn = document.getElementById("day-left");
  Â  Â  Â  const rightBtn = document.getElementById("day-right");

  Â  Â  Â  leftBtn.addEventListener("click", () => {
  Â  Â  Â  Â  if (animating || currentIndex <= 0) return;
  Â  Â  Â  Â  currentIndex--;
  Â  Â  Â  Â  updateDaySelector(currentIndex, "right");
  Â  Â  Â  });

  Â  Â  Â  rightBtn.addEventListener("click", () => {
  Â  Â  Â  Â  if (animating || currentIndex >= sortedKeys.length - 1) return;
  Â  Â  Â  Â  currentIndex++;
  Â  Â  Â  Â  updateDaySelector(currentIndex, "left");
  Â  Â  Â  });


  Â  Â  Â  // ********* Initialisierung *********
  Â  Â  Â  updateDaySelector(currentIndex);

  Â  Â  Â  // ********* Schritt 8: Swipe-Gesten *********
  Â  Â  Â  let touchStartX = null;
  Â  Â  Â  let touchEndX = null;

  Â  Â  Â  const swipeThreshold = 50; // Mindestabstand fÃ¼r einen Swipe in px

  Â  Â  Â  selector.addEventListener("touchstart", function (e) {
  Â  Â  Â  Â  touchStartX = e.changedTouches[0].screenX;
  Â  Â  Â  }, false);

  Â  Â  Â  selector.addEventListener("touchend", function (e) {
  Â  Â  Â  Â  touchEndX = e.changedTouches[0].screenX;
  Â  Â  Â  Â  handleSwipeGesture();
  Â  Â  Â  }, false);

  Â  Â  Â  function handleSwipeGesture() {
  Â  Â  Â  Â  if (animating) return;
  Â  Â  Â  Â  if (touchStartX === null || touchEndX === null) return;
  Â  Â  Â  Â  const diffX = touchEndX - touchStartX;

  Â  Â  Â  Â  if (Math.abs(diffX) > swipeThreshold) {
  Â  Â  Â  Â  Â  if (diffX < 0 && currentIndex < sortedKeys.length - 1) {
  Â  Â  Â  Â  Â  Â  currentIndex++;
  Â  Â  Â  Â  Â  Â  updateDaySelector(currentIndex, "left");
  Â  Â  Â  Â  Â  } else if (diffX > 0 && currentIndex > 0) {
  Â  Â  Â  Â  Â  Â  currentIndex--;
  Â  Â  Â  Â  Â  Â  updateDaySelector(currentIndex, "right");
  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  }

  Â  Â  Â  Â  touchStartX = null;
  Â  Â  Â  Â  touchEndX = null;
  Â  Â  Â  }

  Â  Â  }




  Â  Â  async function parseKML(text) {
  Â  Â  Â  const KMLNS = "http://www.opengis.net/kml/2.2";
  Â  Â  Â  const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

  Â  Â  Â  try {
  Â  Â  Â  Â  setStatus("Parse XML â€¦");
  Â  Â  Â  Â  const parser = new DOMParser();
  Â  Â  Â  Â  const xml = parser.parseFromString(text, "application/xml");
  Â  Â  Â  Â  if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

  Â  Â  Â  Â  timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
  Â  Â  Â  Â  if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
  Â  Â  Â  Â  const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
  Â  Â  Â  Â  if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

  Â  Â  Â  Â  const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
  Â  Â  Â  Â  const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
  Â  Â  Â  Â  const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
  Â  Â  Â  Â  const coordsFormatted = coords.replace(/,/g, ', ');
  Â  Â  Â  Â  const coordParts = coords.split(','); Â // ergibt z.â€¯B. ["9.88", " 49.83", " 220.2"]
  Â  Â  Â  Â  const height = coordParts[2]?.trim() ?? ""; // drittes Element ist die HÃ¶he
  Â  Â  Â  Â  stationEl.innerHTML = `<b>Station:</b> ${stationDesc} &nbsp; <b>HÃ¶he:</b> ${height} m Ã¼. M. &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)} m`;

  Â  Â  Â  Â  const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
  Â  Â  Â  Â  seriesMap = {};

  Â  Â  Â  Â  setStatus("Get UV and PT data â€¦");
  Â  Â  Â  Â  // uv und pt holen und einfÃ¼gen
  Â  Â  Â  Â  try {
  Â  Â  Â  Â  Â  Â  result_uv_and_pt = await runForecastUvAndPt(userLat, userLon);
  Â  Â  Â  Â  Â  Â  console.log(result_uv_and_pt);
  Â  Â  Â  Â  Â  Â  seriesMap["GefÃ¼hlte Temperatur"] = result_uv_and_pt["GFT"].map(wert => {
  Â  Â  Â  Â  Â  Â  Â  Â  const celsius = wert - 273.15;
  Â  Â  Â  Â  Â  Â  Â  Â  return Math.round(celsius * 10) / 10;
  Â  Â  Â  Â  Â  Â  });

  Â  Â  Â  Â  Â  Â  seriesMap["UV-Index"] = result_uv_and_pt["UVI"].map(wert => {
  Â  Â  Â  Â  Â  Â  Â  Â  return Math.round(wert * 10) / 10; Â 
  Â  Â  Â  Â  Â  Â  });

  Â  Â  Â  Â  } catch(e) {
  Â  Â  Â  Â  Â  Â  console.warn("Fehler beim Laden von UV-Index und GefÃ¼hlter Temperatur:", e);
  Â  Â  Â  Â  }

  Â  Â  Â  Â  setStatus("Finishing Data â€¦");
  Â  Â  Â  Â  for (const fc of forecasts) {
  Â  Â  Â  Â  Â  const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
  Â  Â  Â  Â  Â  const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
  Â  Â  Â  Â  Â  if (!elName || !valueNode) continue;

  Â  Â  Â  Â  Â  const unit = elementUnitsMap[elName];
  Â  Â  Â  Â  Â  const converter = unitConversionMap[unit];
  Â  Â  Â  Â  Â  const values = valueNode.textContent.trim().split(/\s+/).map(v => {
  Â  Â  Â  Â  Â  Â  if (v === "-" || v === "") return null;
  Â  Â  Â  Â  Â  Â  const num = Number(v);
  Â  Â  Â  Â  Â  Â  if (!Number.isFinite(num)) return v;
  Â  Â  Â  Â  Â  Â  const converted = converter ? converter(num) : num;
  Â  Â  Â  Â  Â  Â  return Math.round(converted * 100) / 100;
  Â  Â  Â  Â  Â  });

  Â  Â  Â  Â  Â  const readableName = elementNamesMap[elName] || elName;
  Â  Â  Â  Â  Â  seriesMap[readableName] = values.slice(0, timeSteps.length);
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // In konsole Werte ausgeben
  Â  Â  Â  Â  console.log("Parsed series:", seriesMap); 

  Â  Â  Â  Â  // Kombiniere Werte mit ihren Fehlern
  Â  Â  Â  Â  for (const { value, error } of combinedParams) {
  Â  Â  Â  Â  Â  if (seriesMap[value] && seriesMap[error]) {
  Â  Â  Â  Â  Â  Â  // Kopiere die Fehlerwerte
  Â  Â  Â  Â  Â  Â  seriesMap[value + "_error"] = seriesMap[error];
  Â  Â  Â  Â  Â  Â  // Fehler-Spalte lÃ¶schen (soll nicht im Dropdown auftauchen)
  Â  Â  Â  Â  Â  Â  delete seriesMap[error];
  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  }

  Â  Â  Â  Â  // Spalten holen
  Â  Â  Â  Â  let cols = Object.keys(seriesMap);

  Â  Â  Â  Â  // Sortieren nach preferredOrder, alles was nicht drinsteht kommt hinten dran
  Â  Â  Â  Â  cols.sort((a, b) => {
  Â  Â  Â  Â  Â  const ia = preferredOrder.indexOf(a);
  Â  Â  Â  Â  Â  const ib = preferredOrder.indexOf(b);
  Â  Â  Â  Â  Â  if (ia === -1 && ib === -1) return a.localeCompare(b); // beide nicht in Liste â†’ alphabetisch
  Â  Â  Â  Â  Â  if (ia === -1) return 1; // a nicht drin â†’ nach hinten
  Â  Â  Â  Â  Â  if (ib === -1) return -1; // b nicht drin â†’ nach hinten
  Â  Â  Â  Â  Â  return ia - ib; // nach Reihenfolge in Liste
  Â  Â  Â  Â  });

  Â  Â  Â  Â  const wide = [];
  Â  Â  Â  Â  for (let i = 0; i < timeSteps.length; i++) {
  Â  Â  Â  Â  Â  const row = { Zeit: fmtLocal(timeSteps[i]) };
  Â  Â  Â  Â  Â  for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
  Â  Â  Â  Â  Â  wide.push(row);
  Â  Â  Â  Â  }
  Â  Â  Â  Â  lastWide = wide;

  Â  Â  Â  Â  // Filtere die Spaltennamen (c), deren OriginalkÃ¼rzel in der Blacklist stehen
  Â  Â  Â  Â  const filteredCols = cols.filter(c => {
  Â  Â  Â  Â  Â  // Alle Fehlerwerte ausschlieÃŸen (Parameternamen, die auf _error enden)
  Â  Â  Â  Â  Â  if (c.endsWith("_error")) return false;

  Â  Â  Â  Â  Â  // Hole das original KÃ¼rzel aus elementNamesMap, falls vorhanden
  Â  Â  Â  Â  Â  const originalKey = Object.keys(elementNamesMap).find(k => elementNamesMap[k] === c);
  Â  Â  Â  Â  Â  // Wenn kein Mapping vorhanden, nimm den angezeigten Namen selbst als Fallback
  Â  Â  Â  Â  Â  const key = originalKey || c;
  Â  Â  Â  Â  Â  return !excludedElements.includes(key);
  Â  Â  Â  Â  });


  Â  Â  Â  Â  plotSel.innerHTML = filteredCols.map(c => {
  Â  Â  Â  Â  const selected = (c === "Temperature 2m above surface") ? "selected" : "";
  Â  Â  Â  Â  return `<option value="${c}" ${selected}>${c}</option>`;
  Â  Â  Â  Â  }).join("");
  Â  Â  Â  Â  plotSel.disabled = false;

  Â  Â  Â  Â  // Wenn Temperatur verfÃ¼gbar, plottet sie zuerst â€“ sonst erster Eintrag
  Â  Â  Â  Â  const defaultParam = filteredCols.includes("Temperature 2m above surface")
  Â  Â  Â  Â  ? "Temperature 2m above surface"
  Â  Â  Â  Â  : filteredCols[0];

  Â  Â  Â  Â  if (defaultParam) {
  Â  Â  Â  Â  renderPlot(defaultParam);
  Â  Â  Â  Â  }

  Â  Â  Â  Â  setStatus("Fertig!");
  Â  Â  Â  Â  buildSummary();

  Â  Â  Â  Â  setTimeout(() => {
  Â  Â  Â  Â  Â  setStatus(""); Â // Versteckt das Status-Element
  Â  Â  Â  Â  Â  document.getElementById("loadButton").style.display = "none"; Â // Versteckt den Button
  Â  Â  Â  Â  Â  document.getElementById("address").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("addressButton").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("result").style.display = "none";
  Â  Â  Â  Â  Â  document.getElementById("confirmButton").style.display = "none";
  Â  Â  Â  Â  }, 0);

  Â  Â  Â  } catch (err) {
  Â  Â  Â  Â  console.error(err);
  Â  Â  Â  Â  setStatus("Fehler: " + err.message);
  Â  Â  Â  Â  stationEl.textContent = "";
  Â  Â  Â  }
  Â  Â  }

  Â  Â  function fmtLocal(iso) {
  Â  Â  Â  try {
  Â  Â  Â  Â  return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" });
  Â  Â  Â  } catch {
  Â  Â  Â  Â  return iso;
  Â  Â  Â  }
  Â  Â  }

  Â  Â  let currentParam = null;

  Â  Â  function renderPlot(param) {
  Â  Â  Â  currentParam = param;

  Â  Â  Â  if (!seriesMap[param]) {
  Â  Â  Â  Â  plotlyDiv.innerHTML = "<em>Keine Daten fÃ¼r diesen Parameter</em>";
  Â  Â  Â  Â  return;
  Â  Â  Â  }

  Â  Â  Â  // Fehlerbereich vorhanden?
  Â  Â  Â  const hasError = !!seriesMap[param + "_error"];
  Â  Â  Â  const traces = [];

  Â  Â  Â  // Uv index plot
  Â  Â  Â  if (param.includes("UV-Index")) {
  Â  Â  Â  Â  const day_strings = result_uv_and_pt["uvi_times"]
  Â  Â  Â  Â  const hours = result_uv_and_pt["UVH"] Â  Â  // in 'hh' Format

  Â  Â  Â  Â  const timeStep_uv = day_strings.map((date, i) => {
  Â  Â  Â  Â  Â  Â  const newDate = new Date(date); // Kopie erstellen
  Â  Â  Â  Â  Â  Â  newDate.setUTCHours(hours[i], 0, 0, 0); // Nur UTC-Hours setzen
  Â  Â  Â  Â  Â  Â  return newDate;
  Â  Â  Â  Â  });

  Â  Â  Â  Â  const xData = timeStep_uv
  Â  Â  Â  Â  const yData = seriesMap[param].map(v => v == null ? null : v);


  Â  Â  Â  Â  // Linie in grau
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  Â  mode: "lines",
  Â  Â  Â  Â  Â  Â  line: { width: 2, shape: "spline", color: "rgb(102, 102, 102)" },
  Â  Â  Â  Â  Â  Â  connectgaps: true,
  Â  Â  Â  Â  Â  Â  hoverinfo: "skip",
  Â  Â  Â  Â  Â  Â  showlegend: false
  Â  Â  Â  Â  });

  Â  Â  Â  Â  // Marker anderem grau
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  Â  mode: "markers",
  Â  Â  Â  Â  Â  Â  marker: { size: 6, color: "rgb(68, 68, 68)" }, 
  Â  Â  Â  Â  Â  Â  name: param
  Â  Â  Â  Â  });

  Â  Â  Â  Â  const layout = {
  Â  Â  Â  Â  ...getLayout(param),
  Â  Â  Â  Â  shapes: [
  Â  Â  Â  Â  Â  Â  {
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'paper',
  Â  Â  Â  Â  Â  Â  yref: 'y',
  Â  Â  Â  Â  Â  Â  x0: 0,
  Â  Â  Â  Â  Â  Â  x1: 1,
  Â  Â  Â  Â  Â  Â  y0: 0,
  Â  Â  Â  Â  Â  Â  y1: 3,
  Â  Â  Â  Â  Â  Â  fillcolor: 'rgba(0, 255, 0, 0.2)', // grÃ¼n
  Â  Â  Â  Â  Â  Â  line: { width: 0 }
  Â  Â  Â  Â  Â  Â  },
  Â  Â  Â  Â  Â  Â  {
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'paper',
  Â  Â  Â  Â  Â  Â  yref: 'y',
  Â  Â  Â  Â  Â  Â  x0: 0,
  Â  Â  Â  Â  Â  Â  x1: 1,
  Â  Â  Â  Â  Â  Â  y0: 3,
  Â  Â  Â  Â  Â  Â  y1: 6,
  Â  Â  Â  Â  Â  Â  fillcolor: 'rgba(255, 255, 0, 0.2)', // gelb
  Â  Â  Â  Â  Â  Â  line: { width: 0 }
  Â  Â  Â  Â  Â  Â  },
  Â  Â  Â  Â  Â  Â  {
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'paper',
  Â  Â  Â  Â  Â  Â  yref: 'y',
  Â  Â  Â  Â  Â  Â  x0: 0,
  Â  Â  Â  Â  Â  Â  x1: 1,
  Â  Â  Â  Â  Â  Â  y0: 6,
  Â  Â  Â  Â  Â  Â  y1: 8,
  Â  Â  Â  Â  Â  Â  fillcolor: 'rgba(255, 165, 0, 0.2)', // orange
  Â  Â  Â  Â  Â  Â  line: { width: 0 }
  Â  Â  Â  Â  Â  Â  },
  Â  Â  Â  Â  Â  Â  {
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'paper',
  Â  Â  Â  Â  Â  Â  yref: 'y',
  Â  Â  Â  Â  Â  Â  x0: 0,
  Â  Â  Â  Â  Â  Â  x1: 1,
  Â  Â  Â  Â  Â  Â  y0: 8,
  Â  Â  Â  Â  Â  Â  y1: 11,
  Â  Â  Â  Â  Â  Â  fillcolor: 'rgba(255, 0, 0, 0.2)', // rot
  Â  Â  Â  Â  Â  Â  line: { width: 0 }
  Â  Â  Â  Â  Â  Â  },
  Â  Â  Â  Â  Â  Â  {
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'paper',
  Â  Â  Â  Â  Â  Â  yref: 'y',
  Â  Â  Â  Â  Â  Â  x0: 0,
  Â  Â  Â  Â  Â  Â  x1: 1,
  Â  Â  Â  Â  Â  Â  y0: 11,
  Â  Â  Â  Â  Â  Â  y1: 13,
  Â  Â  Â  Â  Â  Â  fillcolor: 'rgba(128, 0, 128, 0.2)', // lila
  Â  Â  Â  Â  Â  Â  line: { width: 0 }
  Â  Â  Â  Â  Â  Â  }
  Â  Â  Â  Â  ]
  Â  Â  Â  Â  };

  Â  Â  Â  Â  Plotly.newPlot(plotlyDiv, traces, layout, getConfig());

  Â  Â  Â  Â  return;
  Â  Â  Â  }

  Â  Â  Â  if (param.includes("Temperatur")) {
  Â  Â  Â  Â  const gft_time_step = result_uv_and_pt['gft_times']
  Â  Â  Â  Â  const gft_data = seriesMap["GefÃ¼hlte Temperatur"];

  Â  Â  Â  Â  // Linie GefÃ¼hlte Temperatur in rot
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  Â  x: gft_time_step,
  Â  Â  Â  Â  Â  Â  y: gft_data,
  Â  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  Â  mode: "lines",
  Â  Â  Â  Â  Â  Â  line: { width: 2, shape: "spline", color: "rgb(200, 0, 0)" },
  Â  Â  Â  Â  Â  Â  connectgaps: true,
  Â  Â  Â  Â  Â  Â  hoverinfo: "skip",
  Â  Â  Â  Â  Â  Â  showlegend: false
  Â  Â  Â  Â  });

  Â  Â  Â  Â  // Marker GefÃ¼hlte Temperatur in rot
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  Â  x: gft_time_step,
  Â  Â  Â  Â  Â  Â  y: gft_data,
  Â  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  Â  mode: "markers",
  Â  Â  Â  Â  Â  Â  marker: { size: 6, color: "rgb(120, 0, 0)" }, 
  Â  Â  Â  Â  Â  Â  name: "GefÃ¼hlte Temperatur"
  Â  Â  Â  Â  });

  Â  Â  Â  }

  Â  Â  Â  const xData = timeSteps.map(ts => new Date(ts));
  Â  Â  Â  const yData = seriesMap[param].map(v => v == null ? null : v);


  Â  Â  Â  if (hasError) {
  Â  Â  Â  Â  const errorData = seriesMap[param + "_error"];
  Â  Â  Â  Â  const yUpper = yData.map((v, i) => (v != null && errorData[i] != null) ? v + errorData[i] : null);
  Â  Â  Â  Â  const yLower = yData.map((v, i) => (v != null && errorData[i] != null) ? v - errorData[i] : null);

  Â  Â  Â  Â  // FlÃ¤che zwischen upper und lower in hellem Blau
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  x: [...xData, ...xData.slice().reverse()],
  Â  Â  Â  Â  Â  y: [...yUpper, ...yLower.slice().reverse()],
  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  mode: "lines",
  Â  Â  Â  Â  Â  fill: "toself",
  Â  Â  Â  Â  Â  fillcolor: "rgba(79, 79, 79, 0.5)", 
  Â  Â  Â  Â  Â  line: { color: "transparent" },
  Â  Â  Â  Â  Â  hoverinfo: "skip",
  Â  Â  Â  Â  Â  showlegend: false,
  Â  Â  Â  Â  Â  connectgaps: true,
  Â  Â  Â  Â  Â  name: `${param} Fehlerbereich`
  Â  Â  Â  Â  });
  Â  Â  Â  }

  Â  Â  Â  // Nachtbereiche hinzufÃ¼gen (20-8 Uhr) in hellgrau
  Â  Â  Â  let shapes = [];

  Â  Â  Â  if (!param.includes("UV-Index")) {
  Â  Â  Â  Â  const nightColor = 'rgba(241, 241, 241, 0.75)'; // hellgrau
  Â  Â  Â  Â  const datesSet = new Set();

  Â  Â  Â  Â  xData.forEach(dt => {
  Â  Â  Â  Â  Â  const dateStr = dt.toISOString().split('T')[0]; // "YYYY-MM-DD"

  Â  Â  Â  Â  Â  if (datesSet.has(dateStr)) return; // Nur ein Rechteck pro Datum
  Â  Â  Â  Â  Â  datesSet.add(dateStr);

  Â  Â  Â  Â  Â  // Rechteck von 00:00 bis 08:00
  Â  Â  Â  Â  Â  shapes.push({
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'x',
  Â  Â  Â  Â  Â  Â  yref: 'paper',
  Â  Â  Â  Â  Â  Â  x0: new Date(dateStr + "T00:00:00Z"),
  Â  Â  Â  Â  Â  Â  x1: new Date(dateStr + "T06:00:00Z"),
  Â  Â  Â  Â  Â  Â  y0: 0,
  Â  Â  Â  Â  Â  Â  y1: 1,
  Â  Â  Â  Â  Â  Â  fillcolor: nightColor,
  Â  Â  Â  Â  Â  Â  line: { width: 0 },
  Â  Â  Â  Â  Â  Â  layer: 'below'
  Â  Â  Â  Â  Â  });

  Â  Â  Â  Â  Â  // Rechteck von 20:00 bis 23:59
  Â  Â  Â  Â  Â  shapes.push({
  Â  Â  Â  Â  Â  Â  type: 'rect',
  Â  Â  Â  Â  Â  Â  xref: 'x',
  Â  Â  Â  Â  Â  Â  yref: 'paper',
  Â  Â  Â  Â  Â  Â  x0: new Date(dateStr + "T18:00:00Z"),
  Â  Â  Â  Â  Â  Â  x1: new Date(new Date(dateStr + "T23:59:59Z").getTime() + 1000), // leicht drÃ¼ber hinaus
  Â  Â  Â  Â  Â  Â  y0: 0,
  Â  Â  Â  Â  Â  Â  y1: 1,
  Â  Â  Â  Â  Â  Â  fillcolor: nightColor,
  Â  Â  Â  Â  Â  Â  line: { width: 0 },
  Â  Â  Â  Â  Â  Â  layer: 'below'
  Â  Â  Â  Â  Â  });
  Â  Â  Â  Â  });
  Â  Â  Â  }
  Â  Â  Â  if (param.includes("Sonnenstunden-tÃ¤glich")) {
  Â  Â  Â  Â  const xData = timeSteps.map(ts => {
  Â  Â  Â  Â  Â  const date = new Date(ts);
  Â  Â  Â  Â  Â  date.setDate(date.getDate() - 1); // Einen Tag abziehen
  Â  Â  Â  Â  Â  date.setUTCHours(12, 0, 0, 0); Â  Â // Uhrzeit auf 10:00:00.000 UTC setzen
  Â  Â  Â  Â  Â  return date;
  Â  Â  Â  Â  });
  Â  Â  Â  Â  const yData = seriesMap[param].map(v => v == null ? null : v / 60);

  Â  Â  Â  Â  // Linie in grau
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  mode: "lines",
  Â  Â  Â  Â  Â  line: { width: 2, shape: "spline", color: "rgba(17, 24, 39, 1)" },
  Â  Â  Â  Â  Â  connectgaps: true,
  Â  Â  Â  Â  Â  name: param,
  Â  Â  Â  Â  Â  hoverinfo: "skip",
  Â  Â  Â  Â  Â  showlegend: false
  Â  Â  Â  Â  });

  Â  Â  Â  Â  // Marker anderem grau
  Â  Â  Â  Â  traces.push({
  Â  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  Â  mode: "markers",
  Â  Â  Â  Â  Â  marker: { size: 6, color: "rgba(17, 24, 39, 1)" }, 
  Â  Â  Â  Â  Â  name: param
  Â  Â  Â  Â  });

  Â  Â  Â  Â  const layout = {
  Â  Â  Â  Â  Â  ...getLayout(param),
  Â  Â  Â  Â  Â  shapes: shapes
  Â  Â  Â  Â  };

  Â  Â  Â  Â  Plotly.newPlot(plotlyDiv, traces, layout, getConfig());
  Â  Â  Â  Â  return;
  Â  Â  Â  }



  Â  Â  Â  // Linie in grau
  Â  Â  Â  traces.push({
  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  mode: "lines",
  Â  Â  Â  Â  line: { width: 2, shape: "spline", color: "rgba(17, 24, 39, 1)" },
  Â  Â  Â  Â  connectgaps: true,
  Â  Â  Â  Â  name: param,
  Â  Â  Â  Â  hoverinfo: "skip",
  Â  Â  Â  Â  showlegend: false
  Â  Â  Â  });

  Â  Â  Â  // Marker anderem grau
  Â  Â  Â  traces.push({
  Â  Â  Â  Â  x: xData,
  Â  Â  Â  Â  y: yData,
  Â  Â  Â  Â  type: "scatter",
  Â  Â  Â  Â  mode: "markers",
  Â  Â  Â  Â  marker: { size: 6, color: "rgba(17, 24, 39, 1)" }, 
  Â  Â  Â  Â  name: param
  Â  Â  Â  });

  Â  Â  Â  const layout = {
  Â  Â  Â  Â  ...getLayout(param),
  Â  Â  Â  Â  shapes: shapes
  Â  Â  Â  };

  Â  Â  Â  // Wenn Windrichtung â†’ Y-Achse in Richtungssymbolen anzeigen
  Â  Â  Â  if (param.includes("Windrichtung")) {
  Â  Â  Â  Â  layout.yaxis = {
  Â  Â  Â  Â  Â  title: "Windrichtung",
  Â  Â  Â  Â  Â  tickmode: "array",
  Â  Â  Â  Â  Â  tickvals: [0, 90, 180, 270, 360],
  Â  Â  Â  Â  Â  ticktext: ["N", "E", "S", "W", "N"],
  Â  Â  Â  Â  Â  range: [0, 360]
  Â  Â  Â  Â  };
  Â  Â  Â  }
  Â  Â  Â  
  Â  Â  Â  Plotly.newPlot(plotlyDiv, traces, layout, getConfig());
  Â  Â  }


  Â  Â  // Hilfsfunktionen fÃ¼r Layout und Config
  Â  Â  function getLayout(param) {
  Â  Â  // Alle Zeitpunkte als Date-Objekte
  Â  Â  const xData = timeSteps.map(ts => new Date(ts));

  Â  Â  // Bereich: von erstem Zeitpunkt bis +72 Stunden
  Â  Â  let xRange = null;
  Â  Â  if (xData.length > 0) {
  Â  Â  Â  Â  const start = xData[0];
  Â  Â  Â  Â  const end = new Date(start.getTime() + 60 * 3600 * 1000);
  Â  Â  Â  Â  xRange = [start, end];
  Â  Â  }

  Â  Â  return {
  Â  Â  Â  Â  margin: { l: 50, r: 20, t: 30, b: 70 },
  Â  Â  Â  Â  xaxis: {
  Â  Â  Â  Â  title: "Zeit",
  Â  Â  Â  Â  automargin: true,
  Â  Â  Â  Â  range: xRange Â  // <-- Standard-Zoom
  Â  Â  Â  Â  },
  Â  Â  Â  Â  yaxis: { title: param, automargin: true },
  Â  Â  Â  Â  hovermode: "x",
  Â  Â  Â  Â  autosize: true,
  Â  Â  Â  Â  showlegend: false,
  Â  Â  Â  Â  dragmode: "pan"
  Â  Â  };
  Â  Â  }

  Â  Â  function getConfig() {
  Â  Â  Â  return {
  Â  Â  Â  Â  responsive: true,
  Â  Â  Â  Â  displaylogo: false,
  Â  Â  Â  Â  modeBarButtonsToRemove: [
  Â  Â  Â  Â  Â  "toImage",
  Â  Â  Â  Â  Â  "select2d",
  Â  Â  Â  Â  Â  "lasso2d",
  Â  Â  Â  Â  Â  "zoomIn2d",
  Â  Â  Â  Â  Â  "zoomOut2d",
  Â  Â  Â  Â  Â  "autoScale2d",
  Â  Â  Â  Â  Â  "resetScale2d"
  Â  Â  Â  Â  ]
  Â  Â  Â  };
  Â  Â  }



  Â  Â  plotSel.addEventListener("change", e => renderPlot(e.target.value));
  Â </script>
</body>
</html>









