<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Radolan Konturen Karte</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Externe Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>

  <!-- MarchingSquaresJS -->
  <script src="scripts/MarchingSquares.js"></script>

  <style>
    body, html {
      margin: 0; padding: 0; height: 100%;
      display: flex; flex-direction: column;
    }
    #controls {
      padding: 10px;
      background: #f9fafb;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
      order:2;
    }
    #map {
      flex: 1 1 auto; /* Füllt den restlichen Bildschirm */
    }
    .legend {
      position: absolute;
      top: 30px;
      right: 20px;
      padding: 10px;
      background: white;
      line-height: 1.2em;
      font-size: 14px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      border: 1px solid var(--border);
      border-radius: 8px;
      z-index: 1000;
    }
    .legend .scale {
      width: 200px;
      height: 12px;
      background: linear-gradient(to right, #00007F 0%, #0000FF 15%, #007FFF 30%, #00FF00 50%, #FFFF00 70%, #FF7F00 85%, #FF0000 100%);
      margin-bottom: 5px;
      border-radius: 4px;
    }
    
    .legend .labels {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--fg);
    }

    #start {
      background: #4f4f4f;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s ease;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }

    #start:hover {
      background: #333;
    }

    #start:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #output {
      color: #111827;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 8px;
    }


  </style>
</head>
<body>
  <div id="controls">
    <button id="start">Radolan Daten laden und verarbeiten</button>
    <p id="location_output"></p>
    <pre id="output" style="max-height:100px; overflow:auto;"></pre>
  </div>

  <div id="map"></div>

  <div id="legend" class="legend" style="display:none;">
    <div class="scale"></div>
    <div class="labels">
      <span id="minLabel">1 mm/h</span>
      <span id="maxLabel">20 mm/h</span>
    </div>
    <div id="legend-hover" style="margin-top:6px; font-size:14px; display:none;">
      <span id="hoverColorBox" style="display:inline-block; width:16px; height:12px; border:1px solid #ccc; vertical-align:middle; margin-right:6px;"></span>
      <span id="hoverValue"></span>
    </div>
    <div style="font-size:10px; margin-top:6px; color:#444;">
      Quelle: Deutscher Wetterdienst, <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC BY 4.0</a>
    </div>

  </div>


  <script>
    const DateTime = luxon.DateTime;

    // Leaflet Karte initialisieren
    const map = L.map('map').setView([48.1373, 11.57577], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a>-Mitwirkende',
      maxZoom: 18,
    }).addTo(map);

    // Eigenen Pane für die Konturen mit Blend-Mode
    map.createPane('contourPane');
    map.getPane('contourPane').style.zIndex = 450;
    map.getPane('contourPane').style.mixBlendMode = 'multiply';


    const output = document.getElementById('output');

    function attachContourEvents(layer, value) {
      const showValue = () => {
        document.getElementById("hoverColorBox").style.background = colorScale(value).hex();
        document.getElementById("hoverValue").textContent = `${value} mm/h`;
        document.getElementById("legend-hover").style.display = "inline-block";
      };

      const hideValue = () => {
        document.getElementById("legend-hover").style.display = "none";
      };

      layer.on("mouseover", showValue);
      layer.on("mouseout", hideValue);
      layer.on("click", showValue); // Für mobile Geräte
    }



    function getLocation(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          pos => callback(pos.coords.latitude, pos.coords.longitude),
          showError
        );
      } else {
        document.getElementById("location_output").innerText = "Geolocation wird nicht unterstützt.";
      }
    }

    function showError(error) {
      const messages = {
        1: "Zugriff auf Standort verweigert.",
        2: "Standortinformationen nicht verfügbar.",
        3: "Anfrage dauerte zu lange.",
        default: "Unbekannter Fehler."
      };
      document.getElementById("location_output").innerText = messages[error.code] || messages.default;
    }

    // Hilfsfunktion: Erzeuge den Dateinamen nach dem Schema
    function getRadolanFilename() {
      let now = DateTime.utc().minus({ minutes: 5 });
      let minute = Math.floor(now.minute / 15) * 15;
      let rounded = now.set({ minute, second: 0, millisecond: 0 });
      let filenameTime = rounded.toFormat('yyMMddHHmm');
      return `RQ${filenameTime}_000.gz`;
    }

    // Hilfsfunktion: Liest Koordinaten per fetch aus einer Textdatei
    async function parseCoordinatesUrl(url, digits = 8) {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Fehler beim Laden der Datei ${url}`);
      let text = await response.text();
      text = text.replace(/\s+/g, '');
      if (text.length % digits !== 0) {
        throw new Error(`Datei ${url} Länge ist kein Vielfaches von ${digits}`);
      }
      const coords = [];
      for (let i = 0; i < text.length; i += digits) {
        coords.push(parseFloat(text.slice(i, i + digits)));
      }
      return coords;
    }

    // Raster aus 1D-Liste erstellen
    function makeRaster(coords, nCols) {
      if (coords.length % nCols !== 0) {
        throw new Error("Rastergröße stimmt nicht mit Datenlänge überein.");
      }
      const nRows = coords.length / nCols;
      const raster = [];
      for (let i = 0; i < nRows; i++) {
        raster.push(coords.slice(i * nCols, (i + 1) * nCols));
      }
      return raster;
    }

    // Hauptfunktion: Verarbeitung eines gepufferten RADOLAN-Datensatzes
    function readGzRadvorFromBuffer(buffer, nCols = 900) {
      // Die Koordinaten müssen vorher geladen und übergeben werden, nicht hier lokal
      throw new Error("Bitte übergebe lat/lon Koordinaten separat.");
    }

    // Hier Version, die lat/lon als Argumente bekommt
    function readGzRadvorFromBufferWithCoords(buffer, latCoords, lonCoords, nCols = 900) {
      const minLen = Math.min(latCoords.length, lonCoords.length);

      const lat = makeRaster(latCoords.slice(0, minLen), nCols);
      const lon = makeRaster(lonCoords.slice(0, minLen), nCols);

      // Dekomprimieren mit pako
      const raw = pako.ungzip(buffer);
      // Suche ETX (ASCII 3)
      let headerEnd = raw.indexOf(3);
      if (headerEnd === -1) throw new Error('Kein ETX Zeichen gefunden');
      const headerText = new TextDecoder('utf-8').decode(raw.slice(0, headerEnd));
      const binData = raw.slice(headerEnd + 1);

      const shapeMatch = headerText.match(/GP\s+(\d+)x\s*(\d+)/);
      if (!shapeMatch) throw new Error('Shape in Header nicht gefunden');
      const nx = parseInt(shapeMatch[2]);
      const ny = parseInt(shapeMatch[1]);

      const data = [];
      for (let i = 0; i < binData.length; i += 2) {
        data.push(binData[i] + (binData[i+1] << 8)); // little endian
      }

      const dataFloat = data.map(v => (v === 0 || v > 4095) ? 0 : v * 0.1);

      const rasterData = [];
      for (let i = 0; i < ny; i++) {
        rasterData.push(dataFloat.slice(i * nx, (i + 1) * nx));
      }

      return {
        data: rasterData,
        lat: lat,
        lon: lon
      };
    }

    // Index-Koordinaten in Geo-Koordinaten konvertieren
    function convertIndicesToLatLon(line, latGrid, lonGrid) {
      return line.map(([x, y]) => {
        const xi = Math.round(x);
        const yi = Math.round(y);
        if (
          yi >= 0 && yi < latGrid.length &&
          xi >= 0 && xi < latGrid[0].length
        ) {
          return [latGrid[yi][xi], lonGrid[yi][xi]];
        } else {
          return null;
        }
      }).filter(pt => pt !== null);
    }


    // Prüfen, ob eine Linie geschlossen ist
    function isClosed(coords) {
      if (coords.length < 3) return false;
      const [lat1, lon1] = coords[0];
      const [lat2, lon2] = coords[coords.length - 1];
      const dist = Math.hypot(lat1 - lat2, lon1 - lon2);
      return dist < 0.0001; // kleiner Schwellenwert für "fast gleich"
    }

    // Funktion die benötigt wird um die randlinien zu entfernen
    function isLargeOutline(line, width, height) {
      const xs = line.map(([x, _]) => x);
      const ys = line.map(([_, y]) => y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      // Wenn die Linie fast das ganze Raster umspannt (>90% Breite/Höhe)
      const spanX = maxX - minX;
      const spanY = maxY - minY;
      return spanX > 0.9 * width && spanY > 0.9 * height;
    }


    // Funktion zur Berechnung eines Punktes auf einer Catmull-Rom-Spline
    function catmullRomPoint(P0, P1, P2, P3, t, alpha = 0.5) {
        // Hilfsfunktion zur Berechnung der "Knoten"-Positionen.
        // Diese bestimmen den "Abstand" zwischen den Punkten für die Kurvenberechnung.
        function getKnot(t, p0, p1) {
            const d = [p1[0] - p0[0], p1[1] - p0[1]];
            const distSq = d[0] * d[0] + d[1] * d[1];
            // Die Potenz von alpha bestimmt die "Straffheit" der Kurve.
            const power = alpha * 0.5;
            const knotDist = Math.pow(distSq, power);
            return knotDist + t;
        }

        // Berechne die Knoten t0 bis t3
        const t0 = 0;
        const t1 = getKnot(t0, P0, P1);
        const t2 = getKnot(t1, P1, P2);
        const t3 = getKnot(t2, P2, P3);

        // Dies ist der entscheidende Fix:
        // Wenn der Abstand zwischen den Knoten t1 und t2 fast null ist (also P1 und P2
        // sehr nah beieinander oder identisch sind), dann ist die "Kurve" zwischen ihnen
        // einfach der Startpunkt P1. Das verhindert die Division durch Null.
        const t1_t2_diff = t2 - t1;
        if (Math.abs(t1_t2_diff) < 1e-9) {
            return P1;
        }

        // Skaliere t auf den relevanten Knoten-Bereich
        const T = t1 + t * t1_t2_diff;

        // Führe die Interpolation nach dem De-Boor-Algorithmus durch
        const A1_den = (t1 - t0);
        const A1 = (Math.abs(A1_den) < 1e-9) ? P0 : P0.map((c, i) => (t1 - T) / A1_den * c + (T - t0) / A1_den * P1[i]);

        const A2_den = (t2 - t1);
        const A2 = P1.map((c, i) => (t2 - T) / A2_den * c + (T - t1) / A2_den * P2[i]);

        const A3_den = (t3 - t2);
        const A3 = (Math.abs(A3_den) < 1e-9) ? P2 : P2.map((c, i) => (t3 - T) / A3_den * c + (T - t2) / A3_den * P3[i]);

        const B1_den = (t2 - t0);
        const B1 = (Math.abs(B1_den) < 1e-9) ? A1 : A1.map((c, i) => (t2 - T) / B1_den * c + (T - t0) / B1_den * A2[i]);

        const B2_den = (t3 - t1);
        const B2 = (Math.abs(B2_den) < 1e-9) ? A2 : A2.map((c, i) => (t3 - T) / B2_den * c + (T - t1) / B2_den * A3[i]);
        
        // Letzter Interpolationsschritt
        const C1_den = (t2 - t1); // Identisch zu A2_den
        return B1.map((c, i) => (t2 - T) / C1_den * c + (T - t1) / C1_den * B2[i]);
    }
    // Hauptfunktion: Generiert eine geglättete Linie aus einer Punkteliste
    function generateSplinePoints(points, pointsPerSegment = 10, isLoop = false) {
        const smoothedPoints = [];
        const n = points.length;
        if (n < 2) return points;

        for (let i = 0; i < n; i++) {
            // Für geschlossene Schleifen (Polygone) müssen wir die Endpunkte "umwickeln"
            const p0 = isLoop ? points[(i - 1 + n) % n] : (i === 0 ? points[0] : points[i - 1]);
            const p1 = points[i];
            const p2 = points[(i + 1) % n];
            const p3 = isLoop ? points[(i + 2) % n] : (i === n - 1 ? points[n - 1] : points[i + 2] || points[n-1]);

            if (i === 0) smoothedPoints.push(p1);

            // Füge nur Punkte zwischen p1 und p2 hinzu
            if (i < n -1 || isLoop) {
                for (let j = 1; j <= pointsPerSegment; j++) {
                    const t = j / pointsPerSegment;
                    smoothedPoints.push(catmullRomPoint(p0, p1, p2, p3, t));
                }
            }
        }
        // Bei offenen Linien den letzten Punkt explizit hinzufügen
        if (!isLoop) {
          // smoothedPoints.push(points[n-1]); // Letzter Punkt wird durch die Schleife oben schon abgedeckt
        }

        return smoothedPoints;
    }


    // Farbskala mit chroma.js (Beispiel)
    const colorScale = chroma.scale([
      '#00007F', // dunkelblau
      '#0000FF', // blau
      '#007FFF', // cyan
      '#00FF00', // grün
      '#FFFF00', // gelb
      '#FF7F00', // orange
      '#FF0000'  // rot
    ]).domain([0, 20]);
    async function fetchAndProcessRadvor(lat,lon) {
      map.setView([lat, lon], 10);
      const radolanFilename = getRadolanFilename();
      const proxy = 'https://cors-proxy-for-weather-app.stefan-wiedemann01.workers.dev?url=';
      const url = `${proxy}https://opendata.dwd.de/weather/radar/radvor/rq/${radolanFilename}`;

      const phiUrl = 'data/phi_bottom.txt';
      const lambdaUrl = 'data/lambda_bottom.txt';

      try {
        const utcTime = DateTime.fromFormat(radolanFilename.slice(2, 12), 'yyLLddHHmm', { zone: 'utc' });
        const berlinTime = utcTime.setZone('Europe/Berlin');
        const formatted = berlinTime.toFormat("d. LLLL HH:mm 'Uhr'");
        output.textContent += `${formatted}\n`;

        
        const phiCoords = await parseCoordinatesUrl(phiUrl);
        const lambdaCoords = await parseCoordinatesUrl(lambdaUrl);

        const response = await fetch(url);
        if (!response.ok) throw new Error(`Fehler beim Laden: ${response.statusText}`);

        const arrayBuffer = await response.arrayBuffer();
        const buffer = new Uint8Array(arrayBuffer);

        const result = readGzRadvorFromBufferWithCoords(buffer, phiCoords, lambdaCoords);
        const raster = result.data;
        const latGrid = result.lat;
        const lonGrid = result.lon;

        const contourLevels = [0.5, 1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 20];

        window.contourLayers = [];

        const nx = raster[0].length,
              ny = raster.length;

        contourLevels.forEach(level => {
          const lines = MarchingSquaresJS.isoLines(raster, level, { noQuadTree: true });

          lines.forEach(line => {
            // Filtere große Umrandungen (egal ob exakt am Rand oder knapp daneben)
            if (isLargeOutline(line, nx, ny)) return;
              const geoLines = convertIndicesToLatLon(line, latGrid, lonGrid);
              const closed = isClosed(geoLines);

              // Generiere die geglätteten Punkte.
              // Für geschlossene Polygone setzen wir isLoop auf true.
              const smoothGeoLines = generateSplinePoints(geoLines, 8, closed); 

              if (closed) {
                const polygon = L.polygon(smoothGeoLines, { // <-- smoothGeoLines verwenden
                  pane: 'contourPane',
                  color: colorScale(level).hex(),
                  fillColor: colorScale(level).hex(),
                  fillOpacity: 0.4,
                  weight: 1
                }).addTo(map);
                attachContourEvents(polygon, level);
                window.contourLayers.push(polygon);
              } else {
                const polyline = L.polyline(smoothGeoLines, { // <-- smoothGeoLines verwenden
                  pane: 'contourPane',
                  color: colorScale(level).hex(),
                  weight: 2,
                  opacity: 1
                }).addTo(map);
                attachContourEvents(polyline, level);
                window.contourLayers.push(polyline);
              }
          });
        });



        // Legende anzeigen
        document.getElementById('legend').style.display = 'block';
        document.getElementById('minLabel').textContent = '1 mm/h';
        document.getElementById('maxLabel').textContent = '20 mm/h';
        document.getElementById('start').style.display = 'none';

      } catch (err) {
        output.textContent += `Fehler: ${err.message}\n`;
        console.error(err);
      }
    }

    document.getElementById('start').addEventListener('click', () => {
      getLocation(fetchAndProcessRadvor);
    });
    

  </script>

</body>
</html>
