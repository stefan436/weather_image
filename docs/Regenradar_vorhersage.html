<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>RV Kompositkarte mit gefüllten Konturen (D3.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Hilfsbibliotheken -->
  <script src="https://cdn.jsdelivr.net/npm/js-untar@2.0.0/build/dist/untar.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chroma-js@2.4.2/chroma.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/h5wasm@0.8.3/dist/iife/h5wasm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.19.10/dist/proj4.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <link rel="stylesheet" href="styles/regenradar_vorhersage_style.css" />
</head>
<body>
  <div id="controls">
    <button id="start">RV Daten laden & animieren</button>
    <p id="location_output"></p>

    <label id="loadProgressLabel">Dateien lesen:</label>
    <progress id="loadProgress" value="0" max="100" style="width:300px;"></progress>
    <span id="loadProgressText">0%</span>

    <label id="renderProgressLabel">Konturen berechnen:</label>
    <progress id="renderProgress" value="0" max="100" style="width:300px;"></progress>
    <span id="renderProgressText">0%</span>

    <span id="frameLabel">---</span>
    <input id="frameSlider" type="range" min="0" max="24" value="0" style="width:300px;" disabled />
    <button id="playPause" disabled>▶️ Play</button>
  </div>

  <div id="map"></div>

  <div id="legend" class="legend" style="display:none;">
    <div class="scale"></div>
    <div class="labels">
      <span id="minLabel">1 mm/h</span>
      <span id="maxLabel">30 mm/h</span>
    </div>
    <div id="legend-hover" style="margin-top:6px; font-size:14px; display:none;">
      <span id="hoverColorBox" style="display:inline-block; width:16px; height:12px; border:1px solid #ccc; vertical-align:middle; margin-right:6px;"></span>
      <span id="hoverValue"></span>
    </div>
  </div>



  <script>
    const map = L.map('map').setView([48.1373, 11.57577], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }).addTo(map);
    map.createPane('contourPane');
    map.getPane('contourPane').style.zIndex = 450;
    map.getPane('contourPane').style.mixBlendMode = 'multiply';
    const mapEl = document.getElementById('map');
    new ResizeObserver(() => map.invalidateSize()).observe(mapEl);


    const colorScale = chroma.scale(['#00007F','#0000FF','#007FFF','#00FF00','#FFFF00','#FF7F00','#FF0000']).domain([0,30]);
    const contourLevels = [0.5, 1, 2, 3, 4, 5, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30];

    const ROWS_TO_KEEP = 450;
    let frames = [];
    let lat, lon;
    let contourLayers = [];
    let preRenderedFrames = [];
    let animationTimer = null;
    let isPlaying = false;
    let currentFrame = 0;
    let forecastTime = 0;

    function getLocation(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          pos => callback(pos.coords.latitude, pos.coords.longitude),
          showError
        );
      } else {
        document.getElementById("location_output").innerText = "Geolocation wird nicht unterstützt.";
      }
    }

    function showError(error) {
      const messages = {
        1: "Zugriff auf Standort verweigert.",
        2: "Standortinformationen nicht verfügbar.",
        3: "Anfrage dauerte zu lange.",
        default: "Unbekannter Fehler."
      };
      document.getElementById("location_output").innerText = messages[error.code] || messages.default;
    }

    async function parseH5File(buffer) {
      await h5wasm.ready;
      const filename = "/tmp.h5";
      h5wasm.FS.writeFile(filename, new Uint8Array(buffer));
      const file = new h5wasm.File(filename, "r");

      const dataSet = file.get("/dataset1/data1/data");
      const shape = dataSet.shape;
      const raw = dataSet.to_array();
      const what = file.get("/dataset1/data1/what");
      const nodata = what.attrs['nodata'].value;
      forecastTime = file.get("what").attrs['time'].value;

      file.close();

      const startRow = shape[0] - ROWS_TO_KEEP;
      const sliced = raw.slice(startRow).map(row =>
        row.map(v => (v === nodata ? 0 : (v * 0.01) * 12))
      );

      return { data: sliced };
    }

    async function createCoords() {
      const response = await fetch('data/coords_radarcomposite_rv.bin');
      const buffer = await response.arrayBuffer();
      const view = new DataView(buffer);

      let offset = 0;
      const height = view.getUint32(offset, true); offset += 4;
      const width = view.getUint32(offset, true); offset += 4;
      const numValues = height * width;

      const lat1D = new Float32Array(buffer, offset, numValues); offset += numValues * 4;
      const lon1D = new Float32Array(buffer, offset, numValues);

      const startRow = height - ROWS_TO_KEEP;
      const lat2D = [], lon2D = [];
      for (let y = startRow; y < height; y++) {
        const latRow = [], lonRow = [];
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          latRow.push(lat1D[idx]);
          lonRow.push(lon1D[idx]);
        }
        lat2D.push(latRow);
        lon2D.push(lonRow);
      }
      return { lat: lat2D, lon: lon2D };
    }

    function convertIndicesToLatLon(line, latGrid, lonGrid) {
      return line.map(([x, y]) => {
        const xi = Math.round(x), yi = Math.round(y);
        if (yi >= 0 && yi < latGrid.length && xi >= 0 && xi < latGrid[0].length)
          return [latGrid[yi][xi], lonGrid[yi][xi]];
        return null;
      }).filter(pt => pt !== null);
    }

    function isClosed(coords) {
      if (coords.length < 3) return false;
      const [lat1, lon1] = coords[0];
      const [lat2, lon2] = coords[coords.length - 1];
      return Math.hypot(lat1 - lat2, lon1 - lon2) < 0.0001;
    }

    async function renderAllFrames() {
      const renderProgress = document.getElementById('renderProgress');
      const renderProgressText = document.getElementById('renderProgressText');
      renderProgress.style.display = 'inline';
      renderProgressText.style.display = 'inline';

      const requestIdle = window.requestIdleCallback || (cb => setTimeout(cb, 0));

      for (let idx = 0; idx < frames.length; idx++) {
        const raster = frames[idx];
        const contours = d3.contours()
          .size([raster[0].length, raster.length])
          .thresholds(contourLevels)
          (raster.flat());

        const levelLayers = contours.flatMap(contour => {
          const colorHex = colorScale(contour.value).hex();
          return contour.coordinates.flatMap(geom => {
            return geom.map(ring => {
              const latlngs = convertIndicesToLatLon(ring, lat, lon);
              if (latlngs.length < 3) return null;
              return L.polygon(latlngs, {
                pane: 'contourPane',
                fillColor: colorHex,
                fillOpacity: 0.6,
                color: colorHex,
                weight: 0
              }).on('add', function() {
                attachContourEvents(this, contour.value);
              });
            }).filter(p => p);
          });
        });

        preRenderedFrames.push(levelLayers);
        frames[idx] = null;

        const percent = Math.round(((idx + 1) / frames.length) * 100);
        renderProgress.value = percent;
        renderProgressText.textContent = percent + "%";
        await new Promise(resolve => requestIdle(resolve));
      }
    }

    function renderFrame(idx) {
      contourLayers.forEach(l => map.removeLayer(l));
      contourLayers = [];
      preRenderedFrames[idx].forEach(layer => {
        layer.addTo(map);
        contourLayers.push(layer);
      });
      updateForecastTimeDisplay(idx);
    }


    function updateForecastTimeDisplay(frameIdx) {
      const baseTime = luxon.DateTime
        .utc()
        .set({
          hour: Math.floor(forecastTime / 10000),
          minute: Math.floor(forecastTime / 100) % 100,
          second: forecastTime % 100
        })
        .plus({ minutes: frameIdx * 5 })
        .setZone('Europe/Berlin');

      const formatted = baseTime.toFormat('HH:mm') + ' Uhr';
      document.getElementById('frameLabel').textContent = `${formatted}`;
    }

    function attachContourEvents(polygon, value) {
      const showValue = () => {
        document.getElementById("hoverColorBox").style.background = colorScale(value).hex();
        document.getElementById("hoverValue").textContent = `${value} mm/h`;
        document.getElementById("legend-hover").style.display = "inline-block";
      };

      const hideValue = () => {
        document.getElementById("legend-hover").style.display = "none";
      };

      // Desktop: Maus-Ereignisse
      polygon.on("mouseover", showValue);
      polygon.on("mouseout", hideValue);

      // Mobile: Tipp-Ereignisse
      polygon.on("click", showValue);
    }



    async function fetchAndProcessComposite(lat_pos, lon_pos) {
      map.setView([lat_pos, lon_pos], 10);
      try {
        const proxy = 'https://cors-proxy-for-weather-app.stefan-wiedemann01.workers.dev?url=';
        const tarUrl = `${proxy}https://opendata.dwd.de/weather/radar/composite/rv/composite_rv_LATEST.tar?nocache=${Date.now()}`;
        const resp = await fetch(tarUrl);
        if (!resp.ok) throw new Error("Download fehlgeschlagen");
        const arrayBuffer = await resp.arrayBuffer();

        const entries = await untar(arrayBuffer);
        entries.sort((a, b) => a.name.localeCompare(b.name));

        for (let i = 0; i < entries.length; i++) {
          await new Promise(requestAnimationFrame);
          const parsed = await parseH5File(entries[i].buffer);
          frames.push(parsed.data);
          const percent = Math.round((i + 1) / entries.length * 100);
          document.getElementById('loadProgress').value = percent;
          document.getElementById('loadProgressText').textContent = percent + "%";
        }

        const coords = await createCoords();
        lat = coords.lat;
        lon = coords.lon;

        document.getElementById('frameSlider').max = frames.length - 1;
        document.getElementById('frameSlider').disabled = false;
        document.getElementById('playPause').disabled = false;
        document.getElementById('legend').style.display = 'block';

        await renderAllFrames();
        renderFrame(0);
        map.invalidateSize();

        setTimeout(() => {
          document.getElementById('start').style.display = 'none';
          document.getElementById('loadProgressLabel').style.display = 'none';
          document.getElementById('loadProgress').style.display = 'none';
          document.getElementById('loadProgressText').style.display = 'none';
          document.getElementById('renderProgressLabel').style.display = 'none';
          document.getElementById('renderProgress').style.display = 'none';
          document.getElementById('renderProgressText').style.display = 'none';
          document.getElementById('controls').style.padding = "6px";
          document.getElementById('controls').style.gap = "6px";
          requestAnimationFrame(() => map.invalidateSize());
        }, 1000);
      } catch (e) {
        console.error("Fehler: ", e);
        document.getElementById("location_output").textContent = "Fehler: " + e.message;
      }
    }

    document.getElementById('start').addEventListener('click', () => {
      getLocation(fetchAndProcessComposite);
    });

    document.getElementById('playPause').addEventListener('click', () => {
      if (!isPlaying) {
        isPlaying = true;
        document.getElementById('playPause').textContent = '⏸️ Pause';
        animationTimer = setInterval(() => {
          currentFrame = (currentFrame + 1) % preRenderedFrames.length;
          renderFrame(currentFrame);
          document.getElementById('frameSlider').value = currentFrame;
        }, 500);
      } else {
        isPlaying = false;
        document.getElementById('playPause').textContent = '▶️ Play';
        clearInterval(animationTimer);
      }
    });

    document.getElementById('frameSlider').addEventListener('input', (e) => {
      const idx = parseInt(e.target.value);
      currentFrame = idx;
      renderFrame(currentFrame);
    });
  </script>
</body>
</html>
