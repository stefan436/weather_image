<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Nächste MOSMIX-Station ➜ Tabelle & D3-Plot</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="elementNamesMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
/* Styling aus zweitem HTML beibehalten, leicht erweitert für D3 */
:root {
  --bg: #f9fafb; --fg: #111827; --primary: #2563eb; --primary-hover: #1d4ed8;
  --border: #e5e7eb; --badge-bg: #e0e7ff; --badge-text: #1e3a8a;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
}
body { background: var(--bg); color: var(--fg); margin: 16px; line-height: 1.5; }
h1 { font-size: 1.8rem; font-weight: 600; margin-bottom: 12px; }
.row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; padding: 10px;
  background: white; border: 1px solid var(--border); border-radius: 12px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.btn { background: var(--primary); color: white; border: none;
  border-radius: 8px; padding: 6px 10px; font-size: 14px; transition: background 0.2s ease; }
.btn:hover { background: var(--primary-hover); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.badge { background: var(--badge-bg); color: var(--badge-text);
  padding: 3px 8px; border-radius: 999px; font-size: 12px; font-weight: 500; }
.meta { margin: 10px 0; padding: 10px; background: white; border-radius: 8px; border: 1px solid var(--border); }
.scroll { overflow: auto; max-height: 70vh; margin-top: 10px; border-radius: 8px; border: 1px solid var(--border); background: white; }
table { border-collapse: collapse; width: 100%; }
th, td { border-bottom: 1px solid var(--border); padding: 8px; font-size: 14px; text-align: left; white-space: nowrap; }
th { position: sticky; top: 0; background: #f3f4f6; font-weight: 600; z-index: 1; }
#plot { margin-top: 20px; margin-bottom: 30px; padding: 10px; background: white; border-radius: 8px; border: 1px solid var(--border);
  height: 440px; position: relative; }
.plot-title { font-weight: 600; margin-bottom: 6px; }
.tooltip {
  position: absolute; pointer-events: none; background: #111827; color: #fff; font-size: 12px;
  padding: 6px 8px; border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,.12); opacity: 0; transition: opacity .12s;
  white-space: nowrap;
}
.legend {
  position: absolute; right: 14px; top: 10px; background: rgba(255,255,255,.9);
  border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; font-size: 12px;
}
.axis-label { font-size: 12px; fill: #374151; }
.grid line { stroke: #e5e7eb; stroke-opacity: 1; shape-rendering: crispEdges; }
.grid path { stroke-width: 0; }
.focus-dot { stroke: white; stroke-width: 2px; }
.zoom-hint {
  position: absolute; bottom: 10px; right: 14px; font-size: 12px; color: #6b7280;
}
</style>
</head>
<body>

<h1>Nächste MOSMIX-Station ➜ Tabelle & Plot (D3)</h1>
<div class="row">
  <button class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
  <label for="plotSelect">Plot-Parameter:</label>
  <select id="plotSelect" disabled></select>
  <span id="status" class="badge">Bereit</span>
</div>

<div id="station" class="meta"></div>
<div id="plot">
  <div id="plotTitle" class="plot-title"></div>
  <div id="legend" class="legend">Linie: Wert</div>
  <div id="tooltip" class="tooltip"></div>
  <div class="zoom-hint">Scroll/Pinch: Zoom • Ziehen: Pan • Doppelklick: Reset</div>
</div>
<div class="scroll"><table id="table"></table></div>


<script>
let closest_station_id = null;
let minDistance = Infinity;
const statusEl = document.getElementById("status");
const tableEl  = document.getElementById("table");
const stationEl= document.getElementById("station");
const plotSel  = document.getElementById("plotSelect");
const plotDiv  = document.getElementById("plot");
const plotTitle= document.getElementById("plotTitle");
const tooltip  = document.getElementById("tooltip");
const legendEl = document.getElementById("legend");

let lastWide = null; 
let seriesMap = {};
let timeSteps = [];

function setStatus(txt) { statusEl.textContent = txt; }


function toRadians(deg) { return deg * Math.PI / 180; }
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const φ1 = toRadians(lat1), φ2 = toRadians(lat2);
  const Δφ = toRadians(lat2 - lat1), Δλ = toRadians(lon2 - lon1);
  const a = Math.sin(Δφ / 2) ** 2 +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

async function findNearestStation() {
  setStatus("Lade Stationsliste …");
  try {
    const response = await fetch('mosmix_stationen_coords.json');
    if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
    const data = await response.json();


    if (!navigator.geolocation) {
      setStatus('Geolocation wird nicht unterstützt.');
      return;
    }

    navigator.geolocation.getCurrentPosition(async position => {
      const userLat = position.coords.latitude;
      const userLon = position.coords.longitude;
      let nearest = null;
      

      for (const row of data) {
        const lat = parseFloat(row.lat);
        const lon = parseFloat(row.lon);
        if (isNaN(lat) || isNaN(lon)) continue;
        const distance = haversineDistance(userLat, userLon, lat, lon);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = row;
        }
      }

      if (!nearest) { setStatus('Keine gültigen Koordinaten gefunden.'); return; }
      closest_station_id = nearest.station_id;
      setStatus(`Station gefunden: ${closest_station_id} – lade KMZ …`);
      await loadMosmixData(closest_station_id);
    }, error => {
      setStatus('Fehler beim Standortzugriff: ' + error.message);
    });

  } catch (err) {
    setStatus('Fehler: ' + err.message);
  }
}
async function loadMosmixData(stationId) {
  try {
    const proxy = 'https://corsproxy.io/?';
    const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
    const url = proxy + encodeURIComponent(baseUrl);

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
    const blob = await resp.blob();

    const zip = await JSZip.loadAsync(blob);
    const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
    if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
    const kmlText = await zip.files[kmlFile].async("string");

    parseKML(kmlText);
  } catch (err) {
    setStatus("Fehler: " + err.message);
  }
}

const unitConversionMap = {
  K: v => v - 273.15, // Kelvin → Celsius
  "m/s": v => v * 3.6, // m/s → km/h
  Pa: v => v / 100, // Pa → hPa
  "kg/m2": v => v, // bleibt gleich (mm Niederschlag)
  "s": v => v / 60, // Sekunden → Minuten
  "1std kJ/m2": v => v/3.6, // Energiedichte in Leistungsdichte [W/m^2] 1 stdunde
  "3std kJ/m2": v => v/10.8, // Energiedichte in Leistungsdichte [W/m^2] 3 stdunden
  "m": v => v, // keine Umrechnung
  "Sichtweite m": v => v/1000, // Meter → kilometer
  "%": v => v, // bleibt gleich
  "-": v => v, // bleibt gleich
  "0°..360°": v => v // Windrichtung bleibt gleich
};

const elementUnitsMap = {
  TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
  FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
  DD: "0°..360°", E_DD: "0°..360°",
  PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
  RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
  Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
  VV: "Sichtweite m", H_BsC: "m",
  SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s",
  // usw. – bei Bedarf erweitern
};


function parseKML(text) {
  const KMLNS = "http://www.opengis.net/kml/2.2";
  const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

  try {
    setStatus("Parse XML …");
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

    timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
    if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
    const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
    if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

    const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
    const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
    const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
    stationEl.innerHTML = `<b>Station:</b> ${stationName} — ${stationDesc} &nbsp; <b>Koordinaten:</b> ${coords} &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)}`;

    const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
    seriesMap = {};

    for (const fc of forecasts) {
      const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
      const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
      if (!elName || !valueNode) continue;

      // Kürzel → Einheit bestimmen
      const unit = elementUnitsMap[elName];

      // Umrechnung nur für numerische Werte anwenden
      const converter = unitConversionMap[unit];

      const values = valueNode.textContent.trim().split(/\s+/).map(v => {
        if (v === "-" || v === "") return null;
        const num = Number(v);
        if (!Number.isFinite(num)) return v;
        const converted = converter ? converter(num) : num;
        return Math.round(converted * 100) / 100; // ➜ auf 2 Nachkommastellen runden
      });


      // Ersetze Kürzel durch Bedeutung, wenn vorhanden
      const readableName = elementNamesMap[elName] || elName;
      seriesMap[readableName] = values.slice(0, timeSteps.length);
    }

    const cols = Object.keys(seriesMap).sort();
    const wide = [];
    for (let i = 0; i < timeSteps.length; i++) {
      const row = { Zeit: fmtLocal(timeSteps[i]) };
      for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
      wide.push(row);
    }
    lastWide = wide;
    renderTable(wide);

    // Dropdown mit übersetzten Parametern
    plotSel.innerHTML = cols.map(c => `<option value="${c}">${c}</option>`).join("");
    plotSel.disabled = false;
    renderPlot(cols[0]);

    setStatus(`OK · ${wide.length} Zeilen × ${1 + cols.length} Spalten`);
  } catch (err) {
    console.error(err);
    setStatus("Fehler: " + err.message);
    tableEl.innerHTML = "";
    stationEl.textContent = "";
  }
}


function fmtLocal(iso) {
  try { return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" }); }
  catch { return iso; }
}
function renderTable(rows) {
  if (!rows.length) { tableEl.innerHTML = "<tbody><tr><td>Keine Daten</td></tr></tbody>"; return; }
  const headers = Object.keys(rows[0]);
  const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r => {
    return `<tr>${headers.map(h => `<td>${r[h] ?? ""}</td>`).join("")}</tr>`;
  }).join("")}</tbody>`;
  tableEl.innerHTML = thead + tbody;
}

/* ===== D3 Plot ===== */
let currentParam = null;
let resizeObserver = null;

function renderPlot(param) {
  currentParam = param;
  plotTitle.textContent = `Verlauf von ${param}`;
  legendEl.textContent = `Linie: ${param}`;

  // Clear old SVG
  d3.select(plotDiv).select("svg").remove();

  if (!seriesMap[param]) {
    plotDiv.insertAdjacentHTML("beforeend", "<em>Keine Daten für diesen Parameter</em>");
    return;
  }

  // Data prep
  const xData = timeSteps.map(ts => new Date(ts));
  let yData = seriesMap[param].map(v => v == null ? null : v);
  let yLabel = param;

  const data = xData.map((x, i) => ({ x, y: yData[i] })).filter(d => d.y != null);

  // Dimensions
  const margin = { top: 16, right: 24, bottom: 36, left: 48 };
  const width  = plotDiv.clientWidth - margin.left - margin.right;
  const height = plotDiv.clientHeight - margin.top - margin.bottom;

  const svg = d3.select(plotDiv)
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  // Scales
  const x = d3.scaleTime().domain(d3.extent(data, d => d.x)).range([0, width]);
  const y = d3.scaleLinear()
    .domain(d3.extent(data, d => d.y)).nice()
    .range([height, 0]);

  // Grid
  const xGrid = d3.axisBottom(x).ticks(Math.min(10, data.length)).tickSize(-height).tickFormat("");
  const yGrid = d3.axisLeft(y).ticks(6).tickSize(-width).tickFormat("");
  g.append("g").attr("class", "grid")
    .attr("transform", `translate(0,${height})`).call(xGrid);
  g.append("g").attr("class", "grid").call(yGrid);

  // Axes
  const xAxis = d3.axisBottom(x).ticks(Math.min(10, data.length))
    .tickFormat(d3.timeFormat("%d.%m %H:%M"));
  const yAxis = d3.axisLeft(y).ticks(6);

  g.append("g").attr("transform", `translate(0,${height})`).call(xAxis);
  g.append("g").call(yAxis);

  // Axis labels
  g.append("text").attr("class", "axis-label")
    .attr("x", width).attr("y", height + 28).attr("text-anchor", "end").text("Zeit");
  g.append("text").attr("class", "axis-label")
    .attr("x", 0).attr("y", -6).attr("text-anchor", "start").text(yLabel);

  // Line
  const line = d3.line()
    .defined(d => d.y != null)
    .x(d => x(d.x))
    .y(d => y(d.y))
    .curve(d3.curveMonotoneX);

  const path = g.append("path")
    .datum(data)
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("d", line);

  // let browser pick a color (no explicit colors)
  path.attr("stroke", getComputedStyle(svg.node()).color || "#111827");

  // Points for better hover targeting
  const points = g.append("g")
    .selectAll("circle").data(data)
    .join("circle")
    .attr("r", 3)
    .attr("cx", d => x(d.x))
    .attr("cy", d => y(d.y))
    .attr("fill", getComputedStyle(svg.node()).color || "#111827")
    .attr("opacity", 0.8);

  // Focus circle & overlay for interactions
  const focus = g.append("circle").attr("class", "focus-dot").attr("r", 5).style("display", "none").attr("fill", "currentColor");
  const overlay = g.append("rect").attr("fill", "transparent").attr("pointer-events", "all").attr("width", width).attr("height", height);

  const bisect = d3.bisector(d => d.x).center;

  function showTooltip(event) {
    const [mx, my] = d3.pointer(event);
    const x0 = x.invert(mx);
    const i = Math.max(0, Math.min(data.length - 1, bisect(data, x0)));
    const d = data[i];
    focus.style("display", null).attr("cx", x(d.x)).attr("cy", y(d.y));
    tooltip.style.opacity = 1;
    tooltip.textContent = `${d3.timeFormat("%d.%m.%Y %H:%M")(d.x)} — ${formatValue(d.y, param)}`;
    const ttRect = tooltip.getBoundingClientRect();
    const parentRect = plotDiv.getBoundingClientRect();
    let left = margin.left + x(d.x) - ttRect.width / 2;
    let top  = margin.top + y(d.y) - ttRect.height - 10;
    left = Math.max(8, Math.min(parentRect.width - ttRect.width - 8, left));
    top  = Math.max(8, Math.min(parentRect.height - ttRect.height - 8, top));
    tooltip.style.left = left + "px";
    tooltip.style.top  = top + "px";
  }
  function hideTooltip() {
    focus.style("display", "none");
    tooltip.style.opacity = 0;
  }
  overlay.on("mousemove", showTooltip).on("mouseleave", hideTooltip);

  // Zoom & Pan
  const zoom = d3.zoom()
    .scaleExtent([1, 24])
    .translateExtent([[0,0],[width, height]])
    .extent([[0,0],[width, height]])
    .on("zoom", (event) => {
      const zx = event.transform.rescaleX(x);
      g.selectAll(".grid").remove();
      g.append("g").attr("class", "grid")
        .attr("transform", `translate(0,${height})`).call(d3.axisBottom(zx).ticks(10).tickSize(-height).tickFormat(""));
      g.select("g:nth-of-type(2)").call(d3.axisBottom(zx).ticks(10).tickFormat(d3.timeFormat("%d.%m %H:%M")));
      g.select("path").attr("d", d3.line()
        .defined(d => d.y != null)
        .x(d => zx(d.x))
        .y(d => y(d.y))
        .curve(d3.curveMonotoneX)(data));
      points.attr("cx", d => zx(d.x));
      overlay.on("mousemove", (ev) => {
        const [mx] = d3.pointer(ev);
        const x0 = zx.invert(mx);
        const i = Math.max(0, Math.min(data.length - 1, bisect(data, x0)));
        const d = data[i];
        focus.style("display", null).attr("cx", zx(d.x)).attr("cy", y(d.y));
        tooltip.style.opacity = 1;
        tooltip.textContent = `${d3.timeFormat("%d.%m.%Y %H:%M")(d.x)} — ${formatValue(d.y, param)}`;
        const ttRect = tooltip.getBoundingClientRect();
        const parentRect = plotDiv.getBoundingClientRect();
        let left = margin.left + zx(d.x) - ttRect.width / 2;
        let top  = margin.top + y(d.y) - ttRect.height - 10;
        left = Math.max(8, Math.min(parentRect.width - ttRect.width - 8, left));
        top  = Math.max(8, Math.min(parentRect.height - ttRect.height - 8, top));
        tooltip.style.left = left + "px";
        tooltip.style.top  = top + "px";
      });
    });

  svg.call(zoom).on("dblclick.zoom", null); // vermeiden: d3 default dblclick-zoom
  svg.on("dblclick", () => {
    svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
  });

  // Responsive: redraw on resize
  if (resizeObserver) resizeObserver.disconnect();
  resizeObserver = new ResizeObserver(() => {
    if (currentParam) renderPlot(currentParam);
  });
  resizeObserver.observe(plotDiv);
}

// hübsche Werte je nach Parameter
function formatValue(v, param) {
  if (v == null || Number.isNaN(v)) return "—";
  return (Math.abs(v) < 10 ? v.toFixed(2) : v.toFixed(1));
}


plotSel.addEventListener("change", () => renderPlot(plotSel.value));
</script>
</body>
</html>
