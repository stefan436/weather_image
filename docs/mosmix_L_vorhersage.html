<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Nächste MOSMIX-Station ➜ Tabelle & Plot (mobilfreundlich)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="elementNamesMap.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <link rel="stylesheet" href="style_mosmix_L_vorhersage.css" />
</head>
<body>

  <h1>Nächste MOSMIX-Station ➜ Tabelle & Plot (mobilfreundlich)</h1>
  <div class="row">
    <button class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
    <label for="plotSelect">Plot-Parameter:</label>
    <select id="plotSelect" disabled></select>
    <span id="status" class="badge">Bereit</span>
  </div>

  <div id="station" class="meta"></div>
  <div id="plot">
    <div id="plotTitle" class="plot-title"></div>
    <div id="plotlyDiv"></div>
  </div>
  <div class="scroll">
    <table id="table"></table>
  </div>

  <script>
  

    // Kürzel, die nicht im Dropdown auftauchen sollen
    const excludedElements = [
      "E_PPP", "E_Td", "FX3", "FX625", "FX640", "FX655", "FXh", "FXh25", "FXh40",
      "PSd00", "PSd30", "PSd60", "R101", "R102", "R103", "R105", "R107", "R110",
      "R120", "R130", "R150", "R600", "R602", "R610", "R650", "RRad1", "Rd00",
      "Rd02", "Rd10", "Rd50", "Rh00", "Rh02", "Rh10", "Rh50", "RR1o1", "RR1u1",
      "RR1w1", "RR3c", "RR6c", "RRdc", "RRhc", "RRL1c", "RRS1c", "RRS3c", "RSunD",
      "SunD", "SunD3", "T5cm", "Td", "TG", "TM", "W1W2", "WPc11", "WPc31", "WPc61",
      "WPcd1", "WPch1", "ww", "ww3", "wwC", "wwC6", "wwCh", "wwD", "wwD6", "wwDh",
      "wwF", "wwF6", "wwFh", "wwL", "wwL6", "wwLh", "wwM6", "wwMd", "wwMh", "wwP6",
      "wwPd", "wwPh", "wwS", "wwS6", "wwSh", "wwT", "wwT6", "wwTd", "wwTh", "wwZ",
      "wwZ6", "wwZh", "FXh55", "N05", "Nh", "Nl", "Nlm", "Nm", "PEvap", "TX", "TN", "N"
    ];

    // Kombinationen von Werten + ihren Fehlern
    const combinedParams = [
      { value: "Temperature 2m above surface", error: "Absolute error temperature 2m above surface" },
      { value: "Wind speed", error: "Absolute error wind speed 10m above surface" },
      { value: "Wind direction", error: "Absolute error wind direction" }
    ];

    let closest_station_id = null;
    let minDistance = Infinity;
    const statusEl = document.getElementById("status");
    const tableEl  = document.getElementById("table");
    const stationEl= document.getElementById("station");
    const plotSel  = document.getElementById("plotSelect");
    const plotTitle= document.getElementById("plotTitle");
    const plotlyDiv= document.getElementById("plotlyDiv");

    let lastWide = null;
    let seriesMap = {};
    let timeSteps = [];

    function setStatus(txt) {
      statusEl.textContent = txt;
    }

    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = toRadians(lat1),
            φ2 = toRadians(lat2);
      const Δφ = toRadians(lat2 - lat1),
            Δλ = toRadians(lon2 - lon1);
      const a = Math.sin(Δφ / 2) ** 2 +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    async function findNearestStation() {
      setStatus("Lade Stationsliste …");
      try {
        const response = await fetch('mosmix_stationen_coords.json');
        if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
        const data = await response.json();

        if (!navigator.geolocation) {
          setStatus('Geolocation wird nicht unterstützt.');
          return;
        }

        navigator.geolocation.getCurrentPosition(async position => {
          const userLat = position.coords.latitude;
          const userLon = position.coords.longitude;
          let nearest = null;

          for (const row of data) {
            const lat = parseFloat(row.lat);
            const lon = parseFloat(row.lon);
            if (isNaN(lat) || isNaN(lon)) continue;
            const distance = haversineDistance(userLat, userLon, lat, lon);
            if (distance < minDistance) {
              minDistance = distance;
              nearest = row;
            }
          }

          if (!nearest) {
            setStatus('Keine gültigen Koordinaten gefunden.');
            return;
          }
          closest_station_id = nearest.station_id;
          setStatus(`Station gefunden: ${closest_station_id} – lade KMZ …`);
          await loadMosmixData(closest_station_id);
        }, error => {
          setStatus('Fehler beim Standortzugriff: ' + error.message);
        });

      } catch (err) {
        setStatus('Fehler: ' + err.message);
      }
    }

    async function loadMosmixData(stationId) {
      try {
        const proxy = 'https://corsproxy.io/?';
        const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
        const url = proxy + encodeURIComponent(baseUrl);

        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
        const blob = await resp.blob();

        const zip = await JSZip.loadAsync(blob);
        const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
        if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
        const kmlText = await zip.files[kmlFile].async("string");

        parseKML(kmlText);
      } catch (err) {
        setStatus("Fehler: " + err.message);
      }
    }

    const unitConversionMap = {
      K: v => v - 273.15,
      "m/s": v => v * 3.6,
      Pa: v => v / 100,
      "kg/m2": v => v,
      "s": v => v / 60,
      "1std kJ/m2": v => v / 3.6,
      "3std kJ/m2": v => v / 10.8,
      "m": v => v,
      "Sichtweite m": v => v / 1000,
      "%": v => v,
      "-": v => v,
      "0°..360°": v => v
    };

    const elementUnitsMap = {
      TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
      FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
      DD: "0°..360°", E_DD: "0°..360°",
      PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
      RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
      Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
      VV: "Sichtweite m", H_BsC: "m",
      SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
    };

    function parseKML(text) {
      const KMLNS = "http://www.opengis.net/kml/2.2";
      const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

      try {
        setStatus("Parse XML …");
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");
        if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

        timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
        if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
        const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
        if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

        const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
        const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
        const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
        stationEl.innerHTML = `<b>Station:</b> ${stationName} — ${stationDesc} &nbsp; <b>Koordinaten:</b> ${coords} &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)}`;

        const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
        seriesMap = {};

        for (const fc of forecasts) {
          const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
          const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
          if (!elName || !valueNode) continue;

          const unit = elementUnitsMap[elName];
          const converter = unitConversionMap[unit];
          const values = valueNode.textContent.trim().split(/\s+/).map(v => {
            if (v === "-" || v === "") return null;
            const num = Number(v);
            if (!Number.isFinite(num)) return v;
            const converted = converter ? converter(num) : num;
            return Math.round(converted * 100) / 100;
          });

          const readableName = elementNamesMap[elName] || elName;
          seriesMap[readableName] = values.slice(0, timeSteps.length);
        }

        // Kombiniere Werte mit ihren Fehlern
        for (const { value, error } of combinedParams) {
          if (seriesMap[value] && seriesMap[error]) {
            // Kopiere die Fehlerwerte
            seriesMap[value + "_error"] = seriesMap[error];
            // Fehler-Spalte löschen (soll nicht im Dropdown auftauchen)
            delete seriesMap[error];
          }
        }


        const cols = Object.keys(seriesMap).sort();
        const wide = [];
        for (let i = 0; i < timeSteps.length; i++) {
          const row = { Zeit: fmtLocal(timeSteps[i]) };
          for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
          wide.push(row);
        }
        lastWide = wide;
        renderTable(wide);

        // Filtere die Spaltennamen (c), deren Originalkürzel in der Blacklist stehen
        const filteredCols = cols.filter(c => {
          // Alle Fehlerwerte ausschließen (Parameternamen, die auf _error enden)
          if (c.endsWith("_error")) return false;

          // Hole das original Kürzel aus elementNamesMap, falls vorhanden
          const originalKey = Object.keys(elementNamesMap).find(k => elementNamesMap[k] === c);
          // Wenn kein Mapping vorhanden, nimm den angezeigten Namen selbst als Fallback
          const key = originalKey || c;
          return !excludedElements.includes(key);
        });


        plotSel.innerHTML = filteredCols.map(c => `<option value="${c}">${c}</option>`).join("");
        plotSel.disabled = false;

        if (filteredCols.length > 0) {
          renderPlot(filteredCols[0]);
        }

        setStatus(`OK · ${wide.length} Zeilen × ${1 + cols.length} Spalten`);
      } catch (err) {
        console.error(err);
        setStatus("Fehler: " + err.message);
        tableEl.innerHTML = "";
        stationEl.textContent = "";
      }
    }

    function fmtLocal(iso) {
      try {
        return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" });
      } catch {
        return iso;
      }
    }

    function renderTable(rows) {
      if (!rows.length) {
        tableEl.innerHTML = "<tbody><tr><td>Keine Daten</td></tr></tbody>";
        return;
      }
      const headers = Object.keys(rows[0]);
      const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr></thead>`;
      const tbody = `<tbody>${rows.map(r => {
        return `<tr>${headers.map(h => `<td>${r[h] ?? ""}</td>`).join("")}</tr>`;
      }).join("")}</tbody>`;
      tableEl.innerHTML = thead + tbody;
    }

    let currentParam = null;

    function renderPlot(param) {
      currentParam = param;
      plotTitle.textContent = `Verlauf von ${param}`;

      if (!seriesMap[param]) {
        plotlyDiv.innerHTML = "<em>Keine Daten für diesen Parameter</em>";
        return;
      }

      const xData = timeSteps.map(ts => new Date(ts));
      const yData = seriesMap[param].map(v => v == null ? null : v);

      // Fehlerbereich vorhanden?
      const hasError = !!seriesMap[param + "_error"];
      const traces = [];

      if (hasError) {
        const errorData = seriesMap[param + "_error"];
        const yUpper = yData.map((v, i) => (v != null && errorData[i] != null) ? v + errorData[i] : null);
        const yLower = yData.map((v, i) => (v != null && errorData[i] != null) ? v - errorData[i] : null);

        // Fläche zwischen upper und lower
        traces.push({
          x: [...xData, ...xData.slice().reverse()],
          y: [...yUpper, ...yLower.slice().reverse()],
          type: "scatter",
          mode: "lines",
          fill: "toself",
          fillcolor: "rgba(37, 99, 235, 0.2)",
          line: { color: "transparent" },
          hoverinfo: "skip",
          showlegend: false,
          connectgaps: true,
          name: `${param} Fehlerbereich`
        });
      }

      // Alle Plots immer mit Spline + Marker
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "lines",
        line: { width: 2, shape: "spline" },
        connectgaps: true,
        name: param,
        showlegend: false
      });
      traces.push({
        x: xData,
        y: yData,
        type: "scatter",
        mode: "markers",
        marker: { size: 6 },
        name: param
      });

      Plotly.newPlot(plotlyDiv, traces, getLayout(param), getConfig());
    }


    // Hilfsfunktionen für Layout und Config
    function getLayout(param) {
      return {
        margin: { l: 50, r: 20, t: 30, b: 70 },
        xaxis: { title: "Zeit", automargin: true },
        yaxis: { title: param, automargin: true },
        hovermode: "x unified",
        autosize: true
      };
    }

    function getConfig() {
      return {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: [
          "toImage",
          "select2d",
          "lasso2d",
          "zoomIn2d",
          "zoomOut2d",
          "autoScale2d",
          "resetScale2d"
        ]
      };
    }



    plotSel.addEventListener("change", e => renderPlot(e.target.value));
  </script>

</body>
</html>
