
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Nächste MOSMIX-Station ➜ Tabelle & Plot (mobilfreundlich)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="elementNamesMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<link rel="stylesheet" href="style_mosmix_L_vorhersage.css">



</head>
<body>

<h1>Nächste MOSMIX-Station ➜ Tabelle & Plot (mobilfreundlich)</h1>
<div class="row">
  <button class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
  <label for="plotSelect">Plot-Parameter:</label>
  <select id="plotSelect" disabled></select>
  <span id="status" class="badge">Bereit</span>
</div>

<div id="station" class="meta"></div>
<div id="plot">
  <div id="plotTitle" class="plot-title"></div>
  <div id="plotlyDiv"></div>
</div>
<div class="scroll"><table id="table"></table></div>

<script>
let closest_station_id = null;
let minDistance = Infinity;
const statusEl = document.getElementById("status");
const tableEl  = document.getElementById("table");
const stationEl= document.getElementById("station");
const plotSel  = document.getElementById("plotSelect");
const plotTitle= document.getElementById("plotTitle");
const plotlyDiv= document.getElementById("plotlyDiv");

let lastWide = null; 
let seriesMap = {};
let timeSteps = [];

function setStatus(txt) { statusEl.textContent = txt; }
function toRadians(deg) { return deg * Math.PI / 180; }
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const φ1 = toRadians(lat1), φ2 = toRadians(lat2);
  const Δφ = toRadians(lat2 - lat1), Δλ = toRadians(lon2 - lon1);
  const a = Math.sin(Δφ / 2) ** 2 +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

async function findNearestStation() {
  setStatus("Lade Stationsliste …");
  try {
    const response = await fetch('mosmix_stationen_coords.json');
    if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
    const data = await response.json();

    if (!navigator.geolocation) {
      setStatus('Geolocation wird nicht unterstützt.');
      return;
    }

    navigator.geolocation.getCurrentPosition(async position => {
      const userLat = position.coords.latitude;
      const userLon = position.coords.longitude;
      let nearest = null;
      
      for (const row of data) {
        const lat = parseFloat(row.lat);
        const lon = parseFloat(row.lon);
        if (isNaN(lat) || isNaN(lon)) continue;
        const distance = haversineDistance(userLat, userLon, lat, lon);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = row;
        }
      }

      if (!nearest) { setStatus('Keine gültigen Koordinaten gefunden.'); return; }
      closest_station_id = nearest.station_id;
      setStatus(`Station gefunden: ${closest_station_id} – lade KMZ …`);
      await loadMosmixData(closest_station_id);
    }, error => {
      setStatus('Fehler beim Standortzugriff: ' + error.message);
    });

  } catch (err) {
    setStatus('Fehler: ' + err.message);
  }
}

async function loadMosmixData(stationId) {
  try {
    const proxy = 'https://corsproxy.io/?';
    const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
    const url = proxy + encodeURIComponent(baseUrl);

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
    const blob = await resp.blob();

    const zip = await JSZip.loadAsync(blob);
    const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
    if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
    const kmlText = await zip.files[kmlFile].async("string");

    parseKML(kmlText);
  } catch (err) {
    setStatus("Fehler: " + err.message);
  }
}

const unitConversionMap = {
  K: v => v - 273.15, "m/s": v => v * 3.6, Pa: v => v / 100, "kg/m2": v => v,
  "s": v => v / 60, "1std kJ/m2": v => v/3.6, "3std kJ/m2": v => v/10.8,
  "m": v => v, "Sichtweite m": v => v/1000, "%": v => v, "-": v => v, "0°..360°": v => v
};

const elementUnitsMap = {
  TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
  FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
  DD: "0°..360°", E_DD: "0°..360°",
  PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
  RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
  Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
  VV: "Sichtweite m", H_BsC: "m",
  SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
};

function parseKML(text) {
  const KMLNS = "http://www.opengis.net/kml/2.2";
  const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

  try {
    setStatus("Parse XML …");
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

    timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
    if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
    const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
    if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

    const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
    const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
    const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
    stationEl.innerHTML = `<b>Station:</b> ${stationName} — ${stationDesc} &nbsp; <b>Koordinaten:</b> ${coords} &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)}`;

    const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
    seriesMap = {};

    for (const fc of forecasts) {
      const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
      const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
      if (!elName || !valueNode) continue;

      const unit = elementUnitsMap[elName];
      const converter = unitConversionMap[unit];
      const values = valueNode.textContent.trim().split(/\s+/).map(v => {
        if (v === "-" || v === "") return null;
        const num = Number(v);
        if (!Number.isFinite(num)) return v;
        const converted = converter ? converter(num) : num;
        return Math.round(converted * 100) / 100;
      });

      const readableName = elementNamesMap[elName] || elName;
      seriesMap[readableName] = values.slice(0, timeSteps.length);
    }

    const cols = Object.keys(seriesMap).sort();
    const wide = [];
    for (let i = 0; i < timeSteps.length; i++) {
      const row = { Zeit: fmtLocal(timeSteps[i]) };
      for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
      wide.push(row);
    }
    lastWide = wide;
    renderTable(wide);

    plotSel.innerHTML = cols.map(c => `<option value="${c}">${c}</option>`).join("");
    plotSel.disabled = false;
    renderPlot(cols[0]);

    setStatus(`OK · ${wide.length} Zeilen × ${1 + cols.length} Spalten`);
  } catch (err) {
    console.error(err);
    setStatus("Fehler: " + err.message);
    tableEl.innerHTML = "";
    stationEl.textContent = "";
  }
}

function fmtLocal(iso) {
  try { return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" }); }
  catch { return iso; }
}

function renderTable(rows) {
  if (!rows.length) { tableEl.innerHTML = "<tbody><tr><td>Keine Daten</td></tr></tbody>"; return; }
  const headers = Object.keys(rows[0]);
  const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r => {
    return `<tr>${headers.map(h => `<td>${r[h] ?? ""}</td>`).join("")}</tr>`;
  }).join("")}</tbody>`;
  tableEl.innerHTML = thead + tbody;
}

let currentParam = null;

function renderPlot(param) {
  currentParam = param;
  plotTitle.textContent = `Verlauf von ${param}`;

  if (!seriesMap[param]) {
    plotlyDiv.innerHTML = "<em>Keine Daten für diesen Parameter</em>";
    return;
  }

  const xData = timeSteps.map(ts => new Date(ts));
  const yData = seriesMap[param].map(v => v == null ? null : v);

  const trace = {
    x: xData,
    y: yData,
    mode: 'lines+markers',
    name: param,
    line: { color: '#2563eb', width: 2 },
    marker: { size: 6 }
  };

  const layout = {
    margin: { l: 50, r: 20, t: 30, b: 50 },
    xaxis: { title: "Zeit" },
    yaxis: { title: param, automargin: true },
    hovermode: "x unified",
    autosize: true
  };

  Plotly.newPlot(plotlyDiv, [trace], layout, {
    responsive: true,
    displaylogo: false,
    modeBarButtonsToRemove: [
      "toImage",          // Png downloaden
      "select2d",         // Box Select
      "lasso2d",          // Lasso Select
      "zoomIn2d",         // Zoom In
      "zoomOut2d",        // Zoom Out
      "autoScale2d",      // Autoscale
      "resetScale2d"      // Reset Axes
    ]
  });

}

plotSel.addEventListener("change", e => renderPlot(e.target.value));
</script>
</body>
</html>
