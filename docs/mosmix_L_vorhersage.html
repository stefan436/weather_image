<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Nächste MOSMIX-Station ➜ Tabelle & D3-Plot (mobilfreundlich)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="elementNamesMap.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
:root {
  --bg: #f9fafb; --fg: #111827; --primary: #2563eb; --primary-hover: #1d4ed8;
  --border: #e5e7eb; --badge-bg: #e0e7ff; --badge-text: #1e3a8a;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
}
body { background: var(--bg); color: var(--fg); margin: 16px; line-height: 1.5; }
h1 { font-size: 1.8rem; font-weight: 600; margin-bottom: 12px; }
.row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; padding: 10px;
  background: white; border: 1px solid var(--border); border-radius: 12px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.btn { background: var(--primary); color: white; border: none;
  border-radius: 8px; padding: 6px 10px; font-size: 14px; transition: background 0.2s ease; }
.btn:hover { background: var(--primary-hover); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.badge { background: var(--badge-bg); color: var(--badge-text);
  padding: 3px 8px; border-radius: 999px; font-size: 12px; font-weight: 500; }
.meta { margin: 10px 0; padding: 10px; background: white; border-radius: 8px; border: 1px solid var(--border); }
.scroll { overflow: auto; max-height: 70vh; margin-top: 10px; border-radius: 8px; border: 1px solid var(--border); background: white; }
table { border-collapse: collapse; width: 100%; }
th, td { border-bottom: 1px solid var(--border); padding: 8px; font-size: 14px; text-align: left; white-space: nowrap; }
th { position: sticky; top: 0; background: #f3f4f6; font-weight: 600; z-index: 1; }
#plot { margin-top: 20px; margin-bottom: 10px; padding: 10px; background: white; border-radius: 8px; border: 1px solid var(--border);
  height: 440px; position: relative; }
.plot-title { font-weight: 600; margin-bottom: 6px; }
.tooltip {
  position: absolute; pointer-events: none; background: rgba(17, 24, 39, 0.9); color: #fff; font-size: 13px;
  padding: 8px; border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,.12); opacity: 0; transition: opacity .12s;
  white-space: nowrap;
}
.legend {
  position: absolute; right: 14px; top: 10px; background: rgba(255,255,255,.9);
  border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; font-size: 12px;
}
.axis-label { font-size: 12px; fill: #374151; }
.grid line { stroke: #e5e7eb; stroke-opacity: 1; shape-rendering: crispEdges; }
.grid path { stroke-width: 0; }
.focus-dot { stroke: white; stroke-width: 2px; }
.zoom-hint {
  position: absolute; bottom: 10px; right: 14px; font-size: 12px; color: #6b7280;
}
.value-readout {
  margin-top: 4px;
  font-size: 13px;
  color: #374151;
  text-align: center;
}
/* Mobile Anpassungen */
@media (max-width: 600px) {
  h1 { font-size: 1.4rem; }
  .row { flex-direction: column; align-items: stretch; }
  .btn, select { width: 100%; }
  #plot { height: 300px; }
}
</style>
</head>
<body>

<h1>Nächste MOSMIX-Station ➜ Tabelle & Plot (mobilfreundlich)</h1>
<div class="row">
  <button class="btn" onclick="findNearestStation()">Standort analysieren & Daten laden</button>
  <label for="plotSelect">Plot-Parameter:</label>
  <select id="plotSelect" disabled></select>
  <span id="status" class="badge">Bereit</span>
</div>

<div id="station" class="meta"></div>
<div id="plot">
  <div id="plotTitle" class="plot-title"></div>
  <div id="legend" class="legend">Linie: Wert</div>
  <div id="tooltip" class="tooltip"></div>
  <div class="zoom-hint">Scroll/Pinch: Zoom • Ziehen: Pan • Doppelklick: Reset</div>
  <div class="value-readout"></div>
</div>
<div class="scroll"><table id="table"></table></div>

<script>
let closest_station_id = null;
let minDistance = Infinity;
const statusEl = document.getElementById("status");
const tableEl  = document.getElementById("table");
const stationEl= document.getElementById("station");
const plotSel  = document.getElementById("plotSelect");
const plotDiv  = document.getElementById("plot");
const plotTitle= document.getElementById("plotTitle");
const tooltip  = document.getElementById("tooltip");
const legendEl = document.getElementById("legend");
const readoutEl= document.querySelector(".value-readout");

let lastWide = null; 
let seriesMap = {};
let timeSteps = [];

function setStatus(txt) { statusEl.textContent = txt; }
function toRadians(deg) { return deg * Math.PI / 180; }
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const φ1 = toRadians(lat1), φ2 = toRadians(lat2);
  const Δφ = toRadians(lat2 - lat1), Δλ = toRadians(lon2 - lon1);
  const a = Math.sin(Δφ / 2) ** 2 +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

async function findNearestStation() {
  setStatus("Lade Stationsliste …");
  try {
    const response = await fetch('mosmix_stationen_coords.json');
    if (!response.ok) throw new Error('JSON konnte nicht geladen werden.');
    const data = await response.json();

    if (!navigator.geolocation) {
      setStatus('Geolocation wird nicht unterstützt.');
      return;
    }

    navigator.geolocation.getCurrentPosition(async position => {
      const userLat = position.coords.latitude;
      const userLon = position.coords.longitude;
      let nearest = null;
      
      for (const row of data) {
        const lat = parseFloat(row.lat);
        const lon = parseFloat(row.lon);
        if (isNaN(lat) || isNaN(lon)) continue;
        const distance = haversineDistance(userLat, userLon, lat, lon);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = row;
        }
      }

      if (!nearest) { setStatus('Keine gültigen Koordinaten gefunden.'); return; }
      closest_station_id = nearest.station_id;
      setStatus(`Station gefunden: ${closest_station_id} – lade KMZ …`);
      await loadMosmixData(closest_station_id);
    }, error => {
      setStatus('Fehler beim Standortzugriff: ' + error.message);
    });

  } catch (err) {
    setStatus('Fehler: ' + err.message);
  }
}

async function loadMosmixData(stationId) {
  try {
    const proxy = 'https://corsproxy.io/?';
    const baseUrl = `https://opendata.dwd.de/weather/local_forecasts/mos/MOSMIX_L/single_stations/${stationId}/kml/MOSMIX_L_LATEST_${stationId}.kmz`;
    const url = proxy + encodeURIComponent(baseUrl);

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`KMZ konnte nicht geladen werden (${resp.status})`);
    const blob = await resp.blob();

    const zip = await JSZip.loadAsync(blob);
    const kmlFile = Object.keys(zip.files).find(f => f.endsWith(".kml"));
    if (!kmlFile) throw new Error("Keine KML in KMZ gefunden.");
    const kmlText = await zip.files[kmlFile].async("string");

    parseKML(kmlText);
  } catch (err) {
    setStatus("Fehler: " + err.message);
  }
}

const unitConversionMap = {
  K: v => v - 273.15, "m/s": v => v * 3.6, Pa: v => v / 100, "kg/m2": v => v,
  "s": v => v / 60, "1std kJ/m2": v => v/3.6, "3std kJ/m2": v => v/10.8,
  "m": v => v, "Sichtweite m": v => v/1000, "%": v => v, "-": v => v, "0°..360°": v => v
};

const elementUnitsMap = {
  TTT: "K", Td: "K", TX: "K", TN: "K", T5cm: "K", TM: "K", TG: "K", E_TTT: "-", E_Td: "-",
  FF: "m/s", FX1: "m/s", FX3: "m/s", FXh: "m/s", E_FF: "m/s",
  DD: "0°..360°", E_DD: "0°..360°",
  PPPP: "Pa", QNH: "Pa", E_PPP: "Pa",
  RR1: "kg/m2", RR3: "kg/m2", RR6: "kg/m2", RR6c: "kg/m2", RR1c: "kg/m2", RR3c: "kg/m2", RRh: "kg/m2", RRhc: "kg/m2", RRd: "kg/m2", RRdc: "kg/m2",
  Rad1h: "1std kJ/m2", RadS3: "3std kJ/m2", RadL3: "3std kJ/m2",
  VV: "Sichtweite m", H_BsC: "m",
  SunD1: "s", SunD3: "s", SunD: "s", DRR1: "s"
};

function parseKML(text) {
  const KMLNS = "http://www.opengis.net/kml/2.2";
  const DWDNS = "https://opendata.dwd.de/weather/lib/pointforecast_dwd_extension_V1_0.xsd";

  try {
    setStatus("Parse XML …");
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    if (xml.getElementsByTagName("parsererror")[0]) throw new Error("XML-Parsing-Fehler");

    timeSteps = Array.from(xml.getElementsByTagNameNS(DWDNS, "TimeStep")).map(n => n.textContent.trim());
    if (timeSteps.length === 0) throw new Error("Keine dwd:TimeStep gefunden.");
    const placemark = xml.getElementsByTagNameNS(KMLNS, "Placemark")[0];
    if (!placemark) throw new Error("Kein kml:Placemark gefunden.");

    const stationName = placemark.getElementsByTagNameNS(KMLNS, "name")[0]?.textContent ?? "";
    const stationDesc = placemark.getElementsByTagNameNS(KMLNS, "description")[0]?.textContent ?? "";
    const coords = placemark.getElementsByTagNameNS(KMLNS, "coordinates")[0]?.textContent?.trim() ?? "";
    stationEl.innerHTML = `<b>Station:</b> ${stationName} — ${stationDesc} &nbsp; <b>Koordinaten:</b> ${coords} &nbsp; <b>Entfernung:</b> ${Math.round(minDistance)}`;

    const forecasts = Array.from(placemark.getElementsByTagNameNS(DWDNS, "Forecast"));
    seriesMap = {};

    for (const fc of forecasts) {
      const elName = fc.getAttributeNS(DWDNS, "elementName") || fc.getAttribute("elementName");
      const valueNode = fc.getElementsByTagNameNS(DWDNS, "value")[0];
      if (!elName || !valueNode) continue;

      const unit = elementUnitsMap[elName];
      const converter = unitConversionMap[unit];
      const values = valueNode.textContent.trim().split(/\s+/).map(v => {
        if (v === "-" || v === "") return null;
        const num = Number(v);
        if (!Number.isFinite(num)) return v;
        const converted = converter ? converter(num) : num;
        return Math.round(converted * 100) / 100;
      });

      const readableName = elementNamesMap[elName] || elName;
      seriesMap[readableName] = values.slice(0, timeSteps.length);
    }

    const cols = Object.keys(seriesMap).sort();
    const wide = [];
    for (let i = 0; i < timeSteps.length; i++) {
      const row = { Zeit: fmtLocal(timeSteps[i]) };
      for (const c of cols) row[c] = seriesMap[c]?.[i] ?? null;
      wide.push(row);
    }
    lastWide = wide;
    renderTable(wide);

    plotSel.innerHTML = cols.map(c => `<option value="${c}">${c}</option>`).join("");
    plotSel.disabled = false;
    renderPlot(cols[0]);

    setStatus(`OK · ${wide.length} Zeilen × ${1 + cols.length} Spalten`);
  } catch (err) {
    console.error(err);
    setStatus("Fehler: " + err.message);
    tableEl.innerHTML = "";
    stationEl.textContent = "";
  }
}

function fmtLocal(iso) {
  try { return new Date(iso).toLocaleString("de-DE", { timeZone: "Europe/Berlin" }); }
  catch { return iso; }
}

function renderTable(rows) {
  if (!rows.length) { tableEl.innerHTML = "<tbody><tr><td>Keine Daten</td></tr></tbody>"; return; }
  const headers = Object.keys(rows[0]);
  const thead = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join("")}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r => {
    return `<tr>${headers.map(h => `<td>${r[h] ?? ""}</td>`).join("")}</tr>`;
  }).join("")}</tbody>`;
  tableEl.innerHTML = thead + tbody;
}

let currentParam = null;
let resizeObserver = null;

function renderPlot(param) {
  currentParam = param;
  plotTitle.textContent = `Verlauf von ${param}`;
  legendEl.textContent = `Linie: ${param}`;
  readoutEl.textContent = "";

  d3.select(plotDiv).select("svg").remove();

  if (!seriesMap[param]) {
    plotDiv.insertAdjacentHTML("beforeend", "<em>Keine Daten für diesen Parameter</em>");
    return;
  }

  const xData = timeSteps.map(ts => new Date(ts));
  let yData = seriesMap[param].map(v => v == null ? null : v);
  const data = xData.map((x, i) => ({ x, y: yData[i] })).filter(d => d.y != null);

  const margin = { top: 16, right: 24, bottom: 36, left: 48 };
  const width  = plotDiv.clientWidth - margin.left - margin.right;
  const height = plotDiv.clientHeight - margin.top - margin.bottom - 20;

  const svg = d3.select(plotDiv)
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const x = d3.scaleTime().domain(d3.extent(data, d => d.x)).range([0, width]);
  const y = d3.scaleLinear().domain(d3.extent(data, d => d.y)).nice().range([height, 0]);

  g.append("g").attr("class", "grid")
    .attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(10).tickSize(-height).tickFormat(""));
  g.append("g").attr("class", "grid").call(d3.axisLeft(y).ticks(6).tickSize(-width).tickFormat(""));

  g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(10).tickFormat(d3.timeFormat("%d.%m %H:%M")));
  g.append("g").call(d3.axisLeft(y));

  g.append("text").attr("x", width/2).attr("y", height + 30).attr("class", "axis-label").attr("text-anchor", "middle").text("Zeit");
  g.append("text").attr("transform", "rotate(-90)").attr("y", -42).attr("x", -height/2).attr("dy", "0.71em").attr("class", "axis-label").attr("text-anchor", "middle").text(param);

  const line = d3.line().x(d => x(d.x)).y(d => y(d.y));
  g.append("path").datum(data).attr("fill", "none").attr("stroke", "#2563eb").attr("stroke-width", 2).attr("d", line);

  const focus = g.append("g").style("display", "none");
  focus.append("circle").attr("class", "focus-dot").attr("r", 5).attr("fill", "#2563eb");

  const bisect = d3.bisector(d => d.x).left;

  function showTooltip(event) {
    const [mx] = d3.pointer(event);
    const x0 = x.invert(mx);
    const i = bisect(data, x0, 1);
    const d0 = data[i - 1], d1 = data[i];
    const d = !d1 ? d0 : (x0 - d0.x > d1.x - x0 ? d1 : d0);

    focus.attr("transform", `translate(${x(d.x)},${y(d.y)})`);
    tooltip.style.opacity = 1
      .html(`<b>${d3.timeFormat("%d.%m %H:%M")(d.x)}</b><br>${param}: ${d.y}`);

    tooltip.style.left = (x(d.x) + margin.left + 10) + "px";
    tooltip.style.top  = (y(d.y) + margin.top - 28) + "px";
    readoutEl.textContent = `${d3.timeFormat("%d.%m %H:%M")(d.x)} → ${d.y}`;
  }

  svg.append("rect").attr("transform", `translate(${margin.left},${margin.top})`)
    .attr("width", width).attr("height", height).attr("fill", "none").attr("pointer-events", "all")
    .on("mouseover touchstart", () => { focus.style("display", null); tooltip.style.opacity = 1; })
    .on("mouseout touchend", () => { focus.style("display", "none"); tooltip.style.opacity = 0; })
    .on("mousemove touchmove", showTooltip);

  if (!resizeObserver) {
    resizeObserver = new ResizeObserver(() => { if (currentParam) renderPlot(currentParam); });
    resizeObserver.observe(plotDiv);
  }
}

plotSel.addEventListener("change", e => renderPlot(e.target.value));
</script>
</body>
</html>